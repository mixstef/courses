.. image:: ../by-sa.png
   :width: 80px
   :alt: Creative Commons Attribution-ShareAlike 4.0 International License

####################################
Λεκτικοί αναλυτές με το module plex
####################################


Στην πλήρη λεκτική ανάλυση πηγαίου κώδικα χρειαζόμαστε κώδικα που αναλύει **όλο το κείμενο εισόδου**: δεν ψάχνουμε μόνο για μεμονωμένα ταιριάσματα, πρέπει να αναγνωρίζουμε τα πάντα, σε μη επικαλυπτόμενα ταιριάσματα.

Η λειτουργία αυτή μπορεί να επιτευχθεί με τα εργαλεία που έχουμε ήδη στη διάθεσή μας, τις κανονικές εκφράσεις της Python. Μπορούμε να κατασκευάσουμε κανονικές εκφράσεις, μία για κάθε είδος token που αναγνωρίζουμε, και να τις συνδυάσουμε σε μια μεγαλύτερη με εναλλαγές (``|``). Στη συνέχεια, με τη βοήθεια διαφορετικών groups θα ανιχνεύουμε τι έχει ταιριάξει και θα επιστρέφουμε το κατάλληλο token. Η διαδικασία θα είναι επαναληπτική, μέχρι να εξαντληθεί όλος ο πηγαίος κώδικας. Ένα πολύ καλό `παράδειγμα (“Writing a Tokenizer”) <https://docs.python.org/3/library/re.html#writing-a-tokenizer>`_ μπορείτε να βρείτε στην τεκμηρίωση της βιβλιοθήκης ``re`` της Python.

Αυτή τη λειτουργία παρέχει το module ``plex``, με έναν απλό και αντικειμενοστρεφή τρόπο.

.. topic:: Προσοχή: βιβλιοθήκη third-party

  Το plex δεν ανήκει στην standard library της Python. Αν χρησιμοποιήσετε το `on-line περιβάλλον <https://mybinder.org/v2/gh/mixstef/mybinder-compilers/HEAD>`_  στο Mybinder.org, το plex είναι προεγκατεστημένο.
  
  Αν δουλέψετε στον δικό σας υπολογιστή θα πρέπει να το εγκαταστήσετε εσείς. Η συνιστώμενη μέθοδος είναι μέσω ενός virtual environment. Δείτε τις οδηγίες για την :ref:`εγκατάσταση και χρήση virtual environments <python-venv-ref>` στην Python.
  

Διαφορές με τις κανονικές εκφράσεις της Python
===============================================
Το plex υλοποιεί τη μηχανή ταιριάσματος **με ντετερμινιστικό αυτόματο (DFA)**, χωρίς backtracking. Αυτό σημαίνει ότι **δεν έχετε στη διάθεσή σας μη-άπληστους τελεστές ή backreferences**, από την άλλη πλευρά όμως η απόδοση είναι ντετερμινιστική και δεν εξαρτάται από το πώς θα γράψετε το σχέδιο ταιριάσματος, ενώ εγγυημένα επιστρέφεται πάντοτε το μεγαλύτερο ταίριασμα.


Χρήση του module plex
======================
Στη συνέχεια περιγράφονται τα βασικά βήματα για τη χρήση του ``plex``.

1. Κάνετε import το plex

   .. code-block:: python
	
	import plex

2. Στη συνέχεια προσδιορίστε τα patterns που θα αναγνωρίζονται (εδώ, τα strings ``abc`` και ``123``, καθώς και διάφοροι χαρακτήρες whitespace):

   .. code-block:: python

	text_abc = plex.Str('abc')
	text_123 = plex.Str('123')
	spaces = plex.Rep1(plex.Any(' \t\n'))

3. Δημιουργήστε ένα ``plex.Lexicon`` με ζευγάρια (pattern,action). Με τον τρόπο αυτόν λέτε στο plex τι θέλετε να αναγνωρίσετε και τι πρέπει να επιστρέφεται κάθε φορά:

   .. code-block:: python
   
	lexicon = plex.Lexicon([
		    (text_abc,'ABC_TOKEN'),
		    (text_123,'123_TOKEN'),
		    (spaces,plex.IGNORE)
	          ])

   Η δημιουργία του ``plex.Lexicon`` ισοδυναμεί με την κατασκευή του αυτομάτου αναγνώρισης (ή αλλιώς, είναι αντίστοιχο του ``re.compile()`` των κανονικών εκφράσεων της Python).
   
   Στο προηγούμενο παράδειγμα προσδιορίζουμε ότι:
   
   * Αν αναγνωριστεί το ``abc``, να επιστραφεί το token ``ABC_TOKEN``.
   * Αν αναγνωριστεί το ``123``, να επιστραφεί το token ``123_TOKEN``.
   * Αν αναγνωριστούν κενά (whitespaces), να αγνοηθούν. Το ``plex.IGNORE`` λέει στο plex να καταναλώσει τους χαρακτήρες αυτούς χωρίς να επιστρέψει κανένα token.      
   
4. Ανοίξτε το αρχείο εισόδου και δημιουργήστε έναν *scanner* (λεκτικό αναλυτή) για το ``plex.Lexicon`` που φτιάξατε προηγουμένως.

   .. code-block:: python

	with open("plex-123-abc.txt","r") as fp:
	    scanner = plex.Scanner(lexicon,fp)

5. Στη συνέχεια, διαβάστε επαναληπτικά τα ζευγάρια (token,lexeme) που επιστρέφει η μέθοδος ``scanner.read()`` μέχρι το τέλος του κειμένου (μέχρι να επιστραφεί το token ``None``):

   .. code-block:: python
   
        while True:
            token,lexeme = scanner.read()
            
            if not token: break	# reached end-of-text (EOT)
            
            print(token,lexeme)	

Το :download:`πλήρες πρόγραμμα <plex-123-abc.py>` φαίνεται στη συνέχεια:

.. literalinclude:: plex-123-abc.py
   :language: python

			
Το αρχείο κειμένου εισόδου :download:`plex-123-abc.txt <plex-123-abc.txt>` μπορεί π.χ. να περιέχει:

::

	abc 123 abc 
	123 abc
	abc123


.. topic:: Είσοδος από string
  
  Θα έχετε παρατηρήσει ότι το ``plex`` μπορεί να αναλύσει μόνο κείμενο από αρχεία. Πώς είναι δυνατή η ανάλυση ενός string; Εδώ έρχεται προς βοήθεια η κλάση ``io.StringIO`` της Python που παρέχει αντικείμενα string που συμπεριφέρονται ως αρχεία:

  .. code-block:: python
  
	from io import StringIO

	text = """
	abc 123 abc 
	123 abc
	abc123

	"""

	scanner = plex.Scanner(lexicon,StringIO(text))  

  
Plex patterns
==============
Αν S, S1, S2 είναι strings, και Β, Ε χαρακτήρες, μπορούν να κατασκευαστούν τα εξής patterns ταιριάσματος:

===========================	================================================================
plex.Str(S)				ταιριάζει το string S
plex.Str(S1,S2,..)			ταιριάζει ένα από τα S1, S2, .. 
plex.Any(S)   				ταιριάζει κάθε έναν από τους χαρακτήρες του S
plex.AnyBut(S) 				ταιριάζει κάθε χαρακτήρα που δεν ανήκει στο S
plex.AnyChar   				ταιριάζει κάθε μονό χαρακτήρα (και το newline)
plex.Empty        			ταιριάζει το κενό string
plex.Bol,plex.Eol,plex.Eof	ταιριάζει στην αρχή/τέλος γραμμής και τέλος κειμένου
plex.Range('BE') 			ταιριάζει περιοχές από το Β έως το Ε (και πολλαπλές π.χ. 'AZaz')
===========================	================================================================

Επίσης, αν P, P1, P2 είναι patterns που έχουν ήδη κατασκευαστεί, μπορούν να γίνουν οι εξής συνδυασμοί:

===========================	=====================================================
P1+P2					το P1 ακολουθούμενο από το P2
P1|P2					είτε το P1 είτε το P2 (εναλλαγή)
plex.Opt(P) 				0 ή 1 φορά το P (προαιρετικό)
plex.Rep(P)  	 			0 ή περισσότερες φορές το P
plex.Rep1(P) 				1 ή περισσότερες φορές το P
plex.NoCase(P),plex.Case(P)		το P, αγνοώντας (ή λαμβάνοντας υπ'όψη) κεφαλαία-μικρά
===========================	=====================================================

(για την πλήρη τεκμηρίωση του plex δείτε το https://pythonhosted.org/plex/) 


Plex και χειρισμός σφαλμάτων
=============================
Κατά τη λειτουργία ενός λεκτικού αναλυτή απαιτείται η αναγνώριση του πλήρους κειμένου: δεν μπορούν να υπάρχουν χαρακτήρες που δεν ταιριάζουν με κάποιο σχέδιο (pattern) του λεκτικού αναλυτή. Αν συμβεί κάτι τέτοιο, προκαλείται **σφάλμα λεκτικής ανάλυσης**. 

Το ``plex`` θα σταματήσει την ανάλυση όταν δεν μπορεί να αναγνωρίσει μέρος της εισόδου με το ``plex.Lexicon`` που χρησιμοποιεί. Μπορείτε να χειριστείτε το σφάλμα ως εξής (:download:`πλήρες αρχείο Python <plex-123-abc-error-handling.py>`):

.. code-block:: python
   
	with open("plex-123-abc-other.txt","r") as fp:

	    scanner = plex.Scanner(lexicon,fp)

	    while True:

		try:
		    token,lexeme = scanner.read()
		    
		except plex.errors.PlexError:
		    _,lineno,charno = scanner.position()	# lineno is 1-based, charno is 0-based
		    print("Scanner Error at line {} char {}".format(lineno,charno+1))
		    break	# lexical analysis ends after error
	    
		if not token: break	# reached end-of-text (EOT)
	    
		print(token,lexeme)	


Κανόνες ταιριάσματος
======================
Γνωρίζουμε ήδη ότι το ``plex`` επιστρέφει πάντα το **μεγαλύτερο σε μήκος ταίριασμα**. Τι συμβαίνει όμως όταν υπάρχουν δύο επιλογές *με το ίδιο ακριβώς μήκος*;

Στο ``plex.Lexicon`` που ακολουθεί, η είσοδος ``then`` ταιριάζει τόσο με το σχέδιο *keywords* («ένα από τα if, then, else») όσο και με το *name* («ονόματα μεταβλητών»). Σε τέτοιες περιπτώσεις, το ``plex`` ταιριάζει **το pattern που δηλώθηκε πρώτο** στο ``plex.Lexicon`` (δηλαδή, εδώ θα ταιριάξει το *keywords* κι όχι το *name*). 

.. code-block:: python

	# define patterns
	letter = plex.Range("AZaz")
	digit = plex.Range("09")
	underscore =  plex.Str("_")

	name = (letter | underscore) + plex.Rep(letter | digit | underscore)
	spaces = plex.Rep1(plex.Any(" \t\n"))

	keywords = plex.Str("if","then","else")

	# the scanner lexicon
	lexicon = plex.Lexicon([
	    (keywords,plex.TEXT),
	    (name, "IDENTIFIER"),
	    (spaces,plex.IGNORE)
	    ])

**Σημ.:** Το ``plex.TEXT`` που φαίνεται στο προηγούμενο ``plex.Lexicon`` λέει στο ``plex`` να επιστρέψει ως token το κείμενο που ταίριαξε (lexeme), δηλ. εδώ ένα από τα ``if``, ``then``, ``else``.

Παράδειγμα #1: Λέξεις και αριθμοί
===================================
Στο επόμενο περιγράφεται λεκτικός αναλυτής με τη βοήθεια του plex, ο οποίος αναγνωρίζει

- *Λέξεις:* συνεχόμενες σειρές από λατινικά γράμματα (κεφαλαία-πεζά)
- *Αριθμούς:* συνεχόμενες σειρές από ψηφία (0 έως 9).
- Κενά, tabs, newlines που αγνοούνται.


.. literalinclude:: plex-words-numbers.py
   :language: python
		
Μπορείτε να κατεβάσετε τα αρχεία με τον :download:`κώδικα Python <plex-words-numbers.py>` και το :download:`δοκιμαστικό κείμενο <plex-words-numbers.txt>` του παραδείγματος.

Παράδειγμα #2: Postfix calculator
===================================
Το plex ως λεκτικός αναλυτής επιστρέφει μια σειρά από tokens χωρίς να εκτελεί οποιουδήποτε τύπου συντακτική ανάλυση. Έτσι, δεν είναι εύκολο να φτιαχτεί χρήσιμη εφαρμογή μόνο με το plex. Υπάρχει όμως ένας τρόπος γραφής αριθμητικών εκφράσεων (`postfix notation <https://en.wikipedia.org/wiki/Reverse_Polish_notation>`_), ο οποίος επιτρέπει τον υπολογισμό τους χωρίς συντακτική ανάλυση. Το παράδειγμα αυτό θα δούμε στη συνέχεια.

Στη μορφή *postfix* ο τελεστής γράφεται αμέσως μετά τα δεδομένα εισόδου. Π.χ. η έκφραση ``3+5`` γράφεται ως:

::

 	3 5 +

ενώ η έκφραση ``8*(3+2)`` γράφεται ως:

::

 	8 3 2 + *

Εάν κάθε τελεστής έχει προκαθορισμένο αριθμό εισόδων (π.χ. το ``+`` δέχεται δύο εισόδους), τότε μπορείτε να υπολογίσετε την αριθμητική έκφραση χωρίς συντακτική ανάλυση, με τη βοήθεια μιας *στοίβας (stack)* και σύμφωνα με τον εξής αλγόριθμο:

::

	Για κάθε token εισόδου:
		Εάν το token είναι αριθμός:
			Βάλε (push) τον αριθμό στη στοίβα
		Αλλιώς, αν είναι τελεστής:
			Πάρε (pop) από τη στοίβα όσα στοιχεία χρειάζεται ο τελεστής
			Κάνε την πράξη
			Βάλε (push) το αποτέλεσμα στη στοίβα

	Όταν εξαντληθούν τα tokens εισόδου, στην κορυφή της στοίβας θα βρίσκεται το τελικό αποτέλεσμα.

.. topic:: Μια (στοιχειώδης) υλοποίηση στοίβας (stack)
  
  Στην Python είναι πολύ εύκολο να φτιάξουμε μια στοίβα χρησιμοποιώντας μια λίστα (list). Για ευκολία, στα επόμενα χρησιμοποιούμε την έτοιμη κλάση ``Stack`` που βρίσκεται στο package ``compilerlabs``. Η κλάση παρέχει μόνο τις βασικές λειτουργίες *push* και *pop*, ενώ δημιουργείται σφάλμα εάν προσπαθήσετε να εξάγετε στοιχείο όταν η στοίβα είναι άδεια. Στο `on-line περιβάλλον <https://mybinder.org/v2/gh/mixstef/mybinder-compilers/HEAD>`_  στο Mybinder.org, το package ``compilerlabs`` είναι προεγκατεστημένο. Για τον υπολογιστή σας δείτε τις οδηγίες για την :ref:`εγκατάσταση και χρήση virtual environments <python-venv-ref>` στην Python.

  Παραδείγματα χρήσης της κλασης ``Stack``:

  .. code-block:: python

	>>> from compilerlabs import Stack
	>>> s = Stack()
	>>> s.push(12.34)
	>>> s.push(9.22)
	>>> s.pop()
	9.22
	>>> s.push(49)
	>>> s.pop()
	49
	>>> s.pop()
	12.34
 
Το επόμενο πρόγραμμα Python υλοποιεί τον αλγόριθμο για υπολογισμό αριθμητικών εκφράσεων σε postfix μορφή. Οι υποστηριζόμενοι τελεστές ειναι οι ``+``, ``-``, ``*``, ``/`` και ο ψευδοτελεστής ``?``, ο οποίος τυπώνει ό,τι βρίσκεται στην κορυφή της στοίβας εκείνη τη στιγμή.

.. literalinclude:: rpn.py
   :language: python
 
Στο προηγούμενο παράδειγμα, χρησιμοποιούμε μια συνάρτηση ανά τελεστή και ένα dictionary για να επιλέγουμε συνάρτηση ανάλογα με τον τελεστή. Θα μπορούσατε εναλλακτικά να υλοποιήσετε τον κώδικα με μια σειρά από ``if..elif..elif..else``.

Μπορείτε να κατεβάσετε τα αρχεία με τον :download:`κώδικα Python <rpn.py>` και το :download:`δοκιμαστικό κείμενο εισόδου <rpn.txt>` του παραδείγματος, που υπολογίζει την έκφραση 

::

	1.1  10  7 -  6  2  /  *  +  ? 

υπολογίζει δηλαδή το ``1.1+(10-7)*(6/2)``.

Ασκήσεις
==========

1. Κατασκευάστε με τη βοήθεια του module ``plex`` λεκτικό αναλυτή ο οποίος θα αναγνωρίζει αριθμητικές σταθερές (literals) στις εξής μορφές:

  - ακέραιες σταθερές (σειρές από ψηφία 0-9 οποιουδήποτε μήκους)
  - κλασματικές (float) σταθερές στη μορφή ``xxx.yyy``, ``.yyy`` και ``xxx.`` (με οποιοδήποτε μήκος x και y)
  - δεκαεξαδικές σταθερές (hex), στη μορφή ``0x****`` όπου το ``*`` αντιστοιχεί σε ένα δεκαεξαδικό ψηφίο (0-9, a-f, A-F) (για οποιονδήποτε αριθμό ψηφίων)
  
  Ο λεκτικός αναλυτής θα πρέπει να επιστρέφει ``INT_TOKEN``, ``FLOAT_TOKEN`` και ``HEX_TOKEN``, αντίστοιχα.
  
2. Προσπαθήστε να προσθέσετε στον προηγούμενο λεκτικό αναλυτή τη δυνατότητα αναγνώρισης **σχολίων μονής γραμμής** στο στυλ της C: ξεκινώντας από ``\\`` και έως το τέλος της γραμμής (μέχρι να βρείτε newline). Τα σχόλια θα πρέπει να αγνοούνται (με το plex.IGNORE).   
