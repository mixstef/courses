Recursive descent parsing
==================================
Οι γραμματικές LL(1) (left-to-right,leftmost-production, 1 lookahead) επιτρέπουν την εύκολη κατασκευή "στο χέρι" top-down parsers μέσω προγραμμάτων αναδρομής (recursive descent). Στη γενική μορφή τους, τα προγράμματα αυτά εκμεταλλεύονται τη "φυσική" οργάνωση σε συναρτήσεις, τις αναδρομικές κλήσεις και τις επιστρεφόμενες τιμές για την υλοποίηση του συντακτικού αναλυτή.


FIRST sets
--------------------------
Το FIRST(x) περιλαμβάνει όλα τα τερματικά σύμβολα, από τα οποία μπορεί να ξεκινάει μια παραγωγή από το x, σε 0 η περισσότερα βήματα. Πρακτικά, ξεκινώντας από κενά FIRST sets, επαναλαμβάνουμε για κάθε κανόνα:

* Εάν το δεξί μέρος ξεκινά με τερματικό σύμβολο ή ε, προσθέτουμε το σύμβολο αυτό στο FIRST set του αριστερού μέρους.
* Αλλιώς, εάν το δεξί μέρος ξεκινά με μη τερματικό σύμβολο, προσθέτουμε το τρέχον FIRST set του μη τερματικού αυτού συμβόλου στο FIRST set του αριστερού μέρους.

  * Εάν συναντήσουμε το ε στο FIRST set του μη τερματικού συμβόλου που προσθέτουμε, αντικαθιστούμε το ε με το τρέχον FIRST set του μη τερματικού συμβόλου που ακολουθεί. Αυτό μπορεί να γίνει διαδοχικά (chain mode). Εάν δεν υπάρχει επόμενο μη τερματικό σύμβολο χωρίς ε, προσθέτουμε το ε στο τελικό FIRST set.
  
* Επαναλαμβάνουμε ξανά τη διαδικασία για όλους τους κανόνες, έως ότου να μην υπάρχουν νέες προσθήκες στα FIRST sets.

FOLLOW sets
----------------
Για τα μη τερματικά σύμβολα που περιέχουν το ε στο FIRST set τους, είναι αναγκαία η εύρεση των αντίστοιχων FOLLOW sets: την ένωση όλων των πιθανών τερματικών συμβόλων (από όλους τους κανόνες) που μπορεί να ακολουθούν κάθε τέτοιο μη τερματικό σύμβολο.

Η πρακτική διαδικασία έχει ως εξής:

* Τα FOLLOW sets αρχικά είναι άδεια.
* Για κάθε δεξί μέρος των κανόνων (ακόμα και για τον εννοούμενο πρώτο κανόνα με το EOT!):

  * Για κάθε μη τερματικό ``Β`` και τυχαίες ακολουθίες συμβόλων ``α``, ``β`` σε κανόνες της μορφής ``Α -> α Β β``, προσθέτουμε το FIRST(β) -εκτός από το ε- στο FOLLOW(B).
  
    * Παρατηρήσεις: 1) το ``α`` μπορεί να είναι κενό (να μην υπάρχει) 2) αν το ``β`` ξεκινά με τερματικό σύμβολο, το FIRST(β) είναι προφανώς το τερματικό εκείνο σύμβολο.
  
  * Για κάθε μη τερματικό ``Β`` και τυχαία ακολουθία συμβόλων ``α`` σε κανόνες της μορφής ``Α -> α Β``, προσθέτουμε το FOLLOW(Α) στο FOLLOW(B).

  * Για κάθε μη τερματικό ``Β`` και τυχαίες ακολουθίες συμβόλων ``α``, ``β`` σε κανόνες της μορφής ``Α -> α Β β``, όπου το ε ανήκει στο FIRST(β), προσθέτουμε το FOLLOW(Α) στο FOLLOW(B).

* Επαναλαμβάνουμε ξανά τη διαδικασία για όλους τους κανόνες, έως ότου να μην υπάρχουν νέες προσθήκες στα FOLLOW sets.


Παράδειγμα γραμματικής
------------------------

Στο παράδειγμα που ακολουθεί:

* η γραμματική δεν έχει αριστερή αναδρομή ούτε κοινούς παράγοντες στους κανόνες
* επιτρέπονται κενές παραγωγές (μέσω του ε)

::

	Απλή γραμματική LL(1) για αριθμητικές εκφράσεις

	<Program>	->	Stmt_list #		(βοηθητικός κανόνας!)
	
	Stmt_list	->	Stmt Stmt_list | ε
	Stmt		->	id = Expr | print Expr
	Expr		->	Term Term_tail
	Term_tail	->	Addop Term Term_tail | ε
	Term		->	Factor Factor_tail
	Factor_tail	->	Multop Factor Factor_tail | ε
	Factor		->	(Expr) | id | number
	Addop		->	+ | -
	Multop		->	* | /


	print: το keyword 'print' 
	id: όνομα μεταβλητής
	number: αριθμητική σταθερά


Ποια τα FIRST και FOLLOW sets της γραμματικής αυτής;




