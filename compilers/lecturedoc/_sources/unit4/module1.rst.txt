Scanning με το Plex
=====================
Η **λεκτική ανάλυση** (scanning) χρησιμοποιείται για να χωρίσουμε ένα κείμενο εισόδου (σε κάποια γλώσσα προγραμματισμού ή εφαρμογής) σε **σύμβολα** (tokens). Σε κανονικές συνθήκες, απαιτούμε **όλο** το κείμενο να μπορεί να αναγνωριστεί ως σύμβολα: αν υπάρχει μέρος του κειμένου που δεν ταιριάζει με κανένα σύμβολο, θέλουμε να παράγεται σφάλμα εκτέλεσης.

Αν και μπορούμε να αναλύσουμε το κείμενο εισόδου με πολλαπλές regular expressions, στα επόμενα θα χρησιμοποιήσουμε το module ``plex``. Αυτό **δεν ανήκει** στη στάνταρ βιβλιοθήκη της Python, έτσι πρέπει να το κατεβάσουμε και να το εγκαταστήσουμε στο σύστημά μας.

Οδηγίες εγκατάστασης
-----------------------
Εάν το module ``plex`` δεν υπάρχει στο σύστημά σας, θα πρέπει να το εγκαταστήσετε από το `PyPi <https://pypi.org/project/plex3/>`_ (ή το ανεπίσημο :download:`Python3 patch<Plex-2.0.1.tar.gz>`)

Υπάρχουν πολλοί τρόποι εγκατάστασης:

1. Αν έχετε το ``virtualenv`` (για την Python3, π.χ. από το package ``python3-virtualenv``) δίνετε:

::

	cd <your virtual env folder> 
	virtualenv venv -p python3 (ή python3 -m virtualenv venv -p python3)
	source venv/bin/activate
	pip install --upgrade plex3 (ή το link του ανεπίσημου patch αντί για plex3) 

Στη συνέχεια μπορείτε να τρέξετε τα δικά σας προγράμματα, αρκεί πάντα το virtual environment να είναι ενεργοποιημένο (με το ``source venv/bin/activate``.

2. Μπορείτε να χρησιμοποιήσετε την εντολή του pip κατευθείαν στο συστημά σας (χωρίς virtualenv) αν έχετε δικαιώματα superuser. Εναλλακτικά προσθέστε ``--user`` για τοπική εγκατάσταση.

3. Τέλος, μπορείτε απλά να αποσυμπιέσετε το ανεπίσημο patch του plex στον φάκελο όπου τρέχετε τα παραδείγματά σας. Φροντίστε όμως τα αρχεία σας να έχουν **διαφορετικά ονόματα** από εκείνα που περιέχονται στο patch!



Απλό παράδειγμα χωρίς έλεγχο λαθών
--------------------------------------
Μην ξεχάσετε να φορτώσετε το module plex:

..	code-block:: python
   
	import plex

Ως πρώτο παράδειγμα, θέλουμε να κατασκευάσουμε έναν scanner που αναγνωρίζει τα σύμβολα ``123`` και ``abc`` (και **τίποτα αλλο**!). Αρχικά κατασκευάζουμε ένα ``plex.Lexicon``, μια λίστα από ζευγάρια ``((pattern,action)``. Το ``pattern`` είναι ένα πρότυπο αναγνώρισης (όπως οι regular expressions που έχουμε ήδη δει) και το ``action`` καθορίζει τι θα επιστρέψει ο scanner όταν ταιριάξει κείμενο με το αντίστοιχο pattern.

Στο παράδειγμα που ακολουθεί, θέλουμε με την εμφάνιση του abc να επιστρέφεται το string ``"ABC_TOKEN"``, ενώ με την εμφάνιση του 123 να επιστρέφεται το string ``"123_TOKEN"``. Επίσης, θέλουμε να αγνοούμε ένα η περισσότερα κενα, tab και newlines (ως action χρησιμοποιείται η ειδική σταθερά ``plex.IGNORE``). Το πώς κατασκευάζεται το pattern θα το δούμε αργότερα.

..	code-block:: python
   
	# the scanner lexicon - constructor argument is a list of (pattern,action ) tuples
	lexicon = plex.Lexicon([
		(plex.Str("abc"),"ABC_TOKEN"),
		(plex.Str("123"),"123_TOKEN"),
		(plex.Rep1(plex.Any(" \t\n")),plex.IGNORE)
		])

Στη συνέχεια, δημιουργούμε ένα αντικείμενο της κλάσης ``plex.Scanner`` για συγκεκριμένο λεξικό και αρχείο:

..	code-block:: python
   
	fp = open("plex1.txt","r")
	scanner = plex.Scanner(lexicon,fp)

Αμέσως μετά, μπορούμε να καλέσουμε επαναληπτικά τη μέθοδο ``read()`` του αντικειμένου scanner. Αυτή η μέθοδος επιστρέφει για κάθε token που αναγνωρίζει ένα ζευγάρι ``(value-returned-from-action,matched-text)``. Όταν δεν υπάρχουν άλλα σύμβολα στο αρχείο εισόδου (end-of-text, EOT), επιστρέφεται το ζευγάρι ``(None, '')``.

..	code-block:: python
   
	while True:
		token,matched = scanner.read()
	
		if not token: break	# reached EOT
	
		print(token,matched)
	 
Το συνολικό πρόγραμμα έχει ως εξής:

.. literalinclude:: plex1.py
   :language: python
   
Φυσικά, με το λεξικό που χρησιμοποιείται, το αρχείο εισόδου πρέπει να αποτελείται **μόνο** από 123 και abc, π.χ. το
:download:`plex1.txt<plex1.txt>`.

.. 	note::

	Μπορείτε να κατεβάσετε `όλα τα αρχεία python και txt <https://gist.github.com/mixstef/25166fe36f89aed4acee>`_. 


Προσθέτοντας έλεγχο λαθών (exception handling)
----------------------------------------------------
Όταν στο αρχείο εισόδου βρεθεί κείμενο που δεν ταιριάζει σε κανένα σύμβολο, δημιουργείται σφάλμα (exception) του τύπου ``plex.errors.PlexError``. Μπορούμε να αναγνωρίσουμε την κατάσταση αυτή με τη δομή ``try: ... except: ...`` της Python
και να βρούμε σε ποιο σημείο του κειμένου συνέβει το σφάλμα, μέσω της μεθόδου ``position()`` του scanner:

.. literalinclude:: plex2.py
   :language: python
   
Εφαρμόζεται στο :download:`plex2.txt<plex2.txt>`.

Plex patterns
-----------------
Αν S, S1, S2 είναι strings, και Β, Ε χαρακτήρες, μπορούν να κατασκευαστούν τα εξής patterns ταιριάσματος:

================	=====================================================
Str(S)			ταιριάζει το string S
Str(S1,S2,..)		ταιριάζει ένα από τα S1, S2, .. 
Any(S)   		ταιριάζει κάθε μονό χαρακτήρα του S
AnyBut(S) 		ταιριάζει κάθε χαρακτήρα που δεν ανήκει στο S
AnyChar   		ταιριάζει κάθε μονό χαρακτήρα (και το newline)
Empty        		ταιριάζει το κενό string
Bol,Eol,Eof   		ταιριάζει στην αρχή/τέλος γραμμής και τέλος κειμένου
Range(“BE..”) 		ταιριάζει περιοχές από το Β έως το Ε κ.ο.κ
================	=====================================================

Επίσης, αν P, P1, P2 είναι patterns που έχουν ήδη κατασκευαστεί, μπορούν να γίνουν οι εξής συνδυασμοί:

=====================	=====================================================
P1+P2 ή Seq(P1,P2)	το P1 ακολουθούμενο από το P2
P1|P2 ή Alt(P1,P2)	είτε το P1 είτε το P2 (εναλλαγή)
Opt(P) 			0 ή 1 φορά το P (προαιρετικό)
Rep(P)  	 	0 ή περισσότερες φορές το P
Rep1(P) 		1 ή περισσότερες φορές το P
NoCase(P)  Case(P)	το P, αγνοώντας (ή λαμβάνοντας υπ'όψη) κεφαλαία-μικρά
=====================	=====================================================

(για την πλήρη τεκμηρίωση του plex δείτε το https://pythonhosted.org/plex/) 

Κανόνες Ταιριάσματος
-----------------------
Στην περίπτωση που υπάρχουν εναλλακτικές επιλογές ταιριάσματος, το plex εφαρμόζει με τη σειρά τους εξής κανόνες:

1. Προτιμάται η επιλογή που επιτυγχάνει το μακρύτερο ταίριασμα (αυτή που ταιριάζει περισσότερους χαρακτήρες).
2. Εάν οι επιλογές ταιριάζουν τον ίδιο αριθμό χαρακτήρων, επιλέγεται η πρώτη, με τη σειρά δήλωσης στο λεξικό.

Ο κανόνας του μακρύτερου ταιριάσματος
----------------------------------------
Γιατί ταιριάζει το ``tomcat`` αντί του ``tom``:

.. literalinclude:: plex3.py
   :language: python
   
Εφαρμόζεται στο :download:`plex3.txt<plex3.txt>`.

Αγνοώντας κείμενο με βάση το μακρύτερο ταίριασμα
--------------------------------------------------------
Δουλεύει για εύρεση tokens με μήκος > 1.

.. literalinclude:: plex4.py
   :language: python
   
Εφαρμόζεται στο :download:`plex4.txt<plex4.txt>`.

Σε ταίριασμα ίδιου μήκους προηγείται ό,τι δηλώθηκε πρώτα
----------------------------------------------------------
Αν το identifier rule είναι πρώτο, δεν θα ταιριάξουμε ποτέ τα keywords!

 .. literalinclude:: plex5.py
   :language: python
   
Εφαρμόζεται στο :download:`plex5.txt<plex5.txt>`.

Αγνοώντας single-line σχόλια
--------------------------------------
Το ζητούμενο είναι η κατασκευή scanner που να αναγνωρίζει

* identifiers
* ακέραιες σταθερές
* σταθερές floating point (στις μορφές xx.yy και .yy, σε οποιοδήποτε αριθμό ψηφίων x και y)
* σταθερές hex (στη μορφή 0x...)
* τα keywords if, the, else, end
* τους τελεστές + - * / = < > (τελεστές ενός χαρακτήρα)

και να αγνοεί:

* newline, tab, space
* οτιδήποτε ακολουθεί // μέχρι το τέλος της γραμμής 


.. literalinclude:: plex6.py
   :language: python
   
Εφαρμόζεται στο :download:`plex6.txt<plex6.txt>`.

Αγνοώντας multiple-line σχόλια /* ... \*/
--------------------------------------------
Αν τα block σχόλια τερματίζονται με έναν μόνο χαρακτήρα, τότε μπορούμε να εφαρμόσουμε μια λύση όπως στο προηγούμενο. Στην περίπτωση που ο τερματισμός των σχολίων απαιτεί μια ακολουθία χαρακτήρων (όπως το ``*/``), είναι πιο εύκολο να χρησιμοποιήσουμε ξεχωριστό state όσο βρισκόμαστε μέσα στο σχόλιο. Εκτός από την απλότητα, το ξεχωριστό state επιτρέπει το χειρισμό nested σχολίων (π.χ. με έναν counter που παρακολουθεί το επίπεδο nesting -δεν υλοποιείται όμως στο επόμενο παράδειγμα) και δεν απαιτεί την αποθήκευση πολλών χαρακτήρων από τον scanner μέχρι το τέλος του σχολίου:


.. literalinclude:: plex7.py
   :language: python
   
Εφαρμόζεται στο :download:`plex7.txt<plex7.txt>`.


