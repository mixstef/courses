.. image:: ../by-sa.png
   :width: 80px
   :alt: Creative Commons Attribution-ShareAlike 4.0 International License


##############################
Κανονικές εκφράσεις
##############################

Στην ενότητα αυτή παρουσιάζονται οι κανονικές εκφράσεις (regular expressions) και η υποστήριξή τους στην Python.



*********************************
Κανονικές εκφράσεις και Python
*********************************

Στην Python (αλλά και σε πολλές άλλες γλώσσες προγραμματισμού) μπορούμε να φανταστούμε μια κανονική έκφραση ως μια μίνι-γλώσσα, η οποία χρησιμοποιείται για τη συγκρότηση μιας *μηχανής ταιριάσματος* (matching engine). Η μηχανή επεξεργάζεται το κείμενο εισόδου σύμφωνα με τις οδηγίες της κανονικής έκφρασης και επιστρέφει

* αν υπάρχει ταίριασμα (αληθές/ψευδές)
* σε ποια σημεία (θέση στο κείμενο)
* ποιο κομμάτι του κειμένου ταίριαξε με την προδιαγραφή
* επίσης, η μηχανή μπορεί να αντικαταστήσει τα κομμάτια που ταίριαξαν, με άλλο κείμενο, αν αυτό ζητηθεί

Η κανονική έκφραση περνά από μια διαδικασία μεταγλώττισης (compilation) και κατασκευάζεται ένα σύνολο οδηγιών για τη μηχανή ταιριάσματος. Η βασική μηχανή είναι γραμμένη σε C και πολύ γρήγορη σε εκτέλεση.

Η υλοποίηση του αυτομάτου που αντιστοιχεί στην κανονική έκφραση υλοποιείται μέσω backtracking. Αυτό σημαίνει ότι οι κανονικές εκφράσεις στην Python έχουν δυνατότητες πέρα από τις μαθηματικές κανονικές εκφράσεις, αλλά ταυτόχρονα απαιτείται προσοχή στον τρόπο κατασκευής της κανονικής έκφρασης: η απόδοση εξαρτάται από το πώς είναι γραμμένη.

.. topic:: Οι κανονικές εκφράσεις δεν είναι πάντοτε η λύση.

	Η χρήση των κανονικών εκφράσεων είναι δύσκολη για τους μη πεπειραμένους και πρέπει να γίνεται με προσοχή. Εξετάστε αν μπορείτε να λύσετε το πρόβλημά σας με πιο απλό τρόπο πριν καταφύγετε στη λύση των κανονικών εκφράσεων. 

	::

	   Some people, when confronted with a problem, think 'I know, I'll use 
	   regular expressions.' Now they have two problems.
		    -- Jamie Zawinski, alt.religion.emacs (08/12/1997)

	Επίσης θα πρέπει πάντοτε να θυμάστε ότι όταν ψάχνουμε **συγκεκριμένα strings σταθερού μήκους** μέσα σε άλλα, οι κανονικές εκφράσεις **δεν είναι η λύση**. Υπάρχουν πολύ πιο αποδοτικοί αλγόριθμοι αναζήτησης strings. Στην Python είναι πάντα προτιμότερο στις περιπτώσεις αυτές να χρησιμοποιούνται μέθοδοι των strings κι όχι κανονικές εκφράσεις:

	.. code-block:: python
	
		>>> s = 'abcd 123'
		>>> i = s.find('123')
		>>> print(i)
		5
		>>> i = s.find('345')
		>>> print(i)
		-1
		>>> s.startswith('abc')
		True
		>>> s.endswith('123')
		True


Χρήση κανονικών εκφράσεων στην Python
======================================

Στην Python η υλοποίηση των κανονικών εκφράσεων είναι αντικειμενοστρεφής.

Η υποστήριξη των regular expressions υπάρχει ενσωματωμένη στη γλώσσα, στο module ``re``:

  ..	code-block:: python
   
	import re

Το ``import`` αυτό γίνεται **μια φορά** στην αρχή του προγράμματός σας και επιτρέπει να χρησιμοποιήσετε όλες τις μεθόδους, τις σταθερές και τα αντικείμενα του module ``re``. 

Στη συνέχεια, μπορείτε να φτιάξετε «μηχανές ταιριάσματος» με τη βοήθεια της συνάρτησης ``re.compile()``, π.χ.:

  ..	code-block:: python
   
	rexp = re.compile('^cat')

Στο προηγούμενο παράδειγμα, η μεταβλητή ``rexp`` είναι η μηχανή ταιριάσματος, ένα αντικείμενο δηλαδή που μας επιτρέπει να ψάξουμε για ταιριάσματα σύμφωνα με την κανονική έκφραση ``^cat``. Το αντικείμενο **κατασκευάζεται άπαξ** (π.χ. στην αρχή του προγράμματος). Στη συνέχεια, μπορούμε να το χρησιμοποιήσουμε **όσες φορές θέλουμε** για να ταιριάξουμε κείμενο:

  ..	code-block:: python
   
	m = rexp.search('category')

Η μέθοδος ``search()`` είναι η βασική μέθοδος της μηχανής αναζήτησης ``rexp`` και αναζητά το σχέδιο ταιριάσματος της αντίστοιχης κανονικής έκφρασης (``^cat``) οπουδήποτε μέσα στο string ``category``. Η επιστρεφόμενη τιμή στη μεταβλητή ``m`` περιέχει ένα «αντικείμενο ταιριάσματος» με πληροφορίες για το τι (αν) ταίριαξε στην αναζήτηση:

* Το ``m`` είναι ``None`` σε περίπτωση αποτυχίας ταιριάσματος.
* Αν υπάρχει ταίριασμα, το ``m`` περιέχει μεθόδους για να λάβουμε την πληροφορία του ταιριάσματος.

Έτσι, μπορούμε για παράδειγμα να γράψουμε:

  ..	code-block:: python
   
	if m:	# m is not None
	
		print('found! matched={}'.format(m.group(0)))
	
	else:	# m is None
		print('not found')   

Το ``m.group(0)`` επιστρέφει το συνολικό κείμενο που ταίριαξε. Τα *groups* είναι μέρη του ταιριάσματος και θα αναλυθούν στα επόμενα.

Στη συνέχεια δίνεται το συνολικό προηγούμενο παράδειγμα

* Στο interactive shell της Python (αν θέλετε να το δοκιμάσετε, ξεκινήστε το interactive shell με την εντολή ``python3`` (ή ``python``) στη κονσόλα/τερματικό/command prompt του λειτουργικού σας. Θυμηθείτε ότι δεν πληκτρολογείτε τα ``>>>``):

    ..	code-block:: python

		>>> import re
		>>> rexp = re.compile('^cat')
		>>> m = rexp.search('I see a cat')
		>>> print(m)
		None
		>>> m = rexp.search('category')
		>>> print(m)
		<_sre.SRE_Match object; span=(0, 3), match='cat'>
		>>> print(m.group(0))
		cat
		>>>
		
* Ως αυτόνομο αρχείο εκτέλεσης (τρέξτε με ``python3 yourfile.py`` ή ``python yourfile.py``):

    ..	code-block:: python

		import re

		rexp = re.compile('^cat')

		m = rexp.search('category')
		
		if m:
			print('found! matched={}'.format(m.group(0)))
		else:
			print('not found')

Στις επόμενες παραγράφους αναφέρονται **μερικά μόνο** από τα εργαλεία της Python για κανονικές εκφράσεις. Για την πλήρη περιγραφή του module ``re``, δείτε στο https://docs.python.org/3/library/re.html\ .

Βασικά σύμβολα κανονικών εκφράσεων
=====================================

Ο πίνακας που ακολουθεί περιέχει τα βασικά σύμβολα που χρησιμοποιούνται για την κατασκευή κανονικών εκφράσεων στην Python (*παρατίθενται μόνο τα σύμβολα που έχουν διδαχθεί έως τώρα στο εργαστήριο*).

==================== 	========================================
``abc``					ταιριάζει ακριβώς το γράμμα ``a``, ακολουθούμενο από το ``b`` και μετά το ``c``
``a|b``					είτε το ``a``, είτε το ``b``
``[abc]``				character class: ένα από τα ``a``, ``b`` ή ``c`` (**προσοχή: ένας χαρακτήρας μόνο**)
``[a-zA-Z]`` 			όπως προηγουμένως, αλλά σε ένα πεδίο τιμών, από ``a`` έως και  ``z`` και από ``A`` έως και ``Z``
``[^ab]``				ένας οποιοσδήποτε χαρακτήρας, **εκτός από** ``a`` ή ``b``
``$``					ταιριάζει **στο τέλος** του string (ρυθμίζεται να ταιριάζει και στο τέλος κάθε γραμμής του string)
``^``					ταιριάζει **στην αρχή** του string (ρυθμίζεται να ταιριάζει και στην αρχή κάθε γραμμής του string)
``.``					ένας **οποιοσδήποτε** χαρακτήρας εκτός από newline (ρυθμίζεται να ταιριάζει και το newline)
``?``					0 ή 1 φορά ο χαρακτήρας που προηγείται
==================== 	========================================

Με βάση τα πιο πάνω μπορούμε να συντάξουμε πιο σύνθετες κανονικές εκφράσεις, συνδυάζοντας πολλές μικρότερες.

Παραδείγματα
=============

Παραδείγματα με τα σύμβολα που έχουν διδαχθεί έως τώρα στο εργαστήριο. Τα παραδείγματα δίνονται στο interactive shell της Python, θεωρήστε ότι έχει προηγηθεί το ``import re``.

.. topic:: Πηγή παραδειγμάτων
   
   Πολλά από τα παραδείγματα που ακολουθούν βασίζονται σε υλικό από το βιβλίο "Mastering Regular Expressions", 2nd ed., Jeffrey E.F. Friedl, O'Reilly Media, July 2002. 


Βρείτε το string ``cat`` στην αρχή ή στο τέλος ενός string:
  
  ..	code-block:: python
  
	>>> rexp = re.compile(r'^cat')
	>>> m = rexp.search('I see a cat')
	>>> print(m)
	None
	>>> m = rexp.search('category')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 3), match='cat'>
	>>> m.group(0)
	'cat'
	>>> rexp = re.compile(r'cat$')
	>>> m = rexp.search('in category')
	>>> print(m)
	None
	>>> m = rexp.search('black cat')
	>>> print m
	<_sre.SRE_Match object; span=(6, 9), match='cat'>
	>>> if m: print('found!')
	... 
	found!
	
Για να ταιριάξουμε ένα άδειο string, θα μπορούσαμε (θεωρητικά -δεν χρειάζεται στην πράξη!) να χρησιμοποιήσουμε το ``'^$'``.

Κλάσεις χαρακτήρων με το ``[]``. Θυμηθείτε ότι μέσα στην κλάση, οι χαρακτήρες ελέγχου χάνουν το ειδικό τους νόημα και το ``^`` σημαίνει κάτι διαφορετικό:

  ..	code-block:: python

	>>> rexp = re.compile(r'gr[ae]y')
	>>> m = rexp.search('a gray cat')
	>>> if m: print('found!')
	... 
	found!
	>>> m = rexp.search('a grey cat')
	>>> if m: print('found!')
	... 
	found!
  
Βρείτε ``a`` που δεν ακολουθείται από ``b``
  
  ..	code-block:: python

	>>> rexp = re.compile(r'a[^b]')
	>>> m = rexp.search('ab')
	>>> print(m)
	None
	>>> m = rexp.search('acb')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 2), match='ac'>
	>>> print(m.group(0))
	ac
	>>> m = rexp.search('ba')
	>>> print(m)
	None
  
Στο τελευταίο παράδειγμα βλέπουμε ότι ενώ το ``a`` δεν πρέπει να ακολουθείται από ``b``, **πρέπει όμως να ακολουθείται από κάτι άλλο**.
    
Βρείτε το gray ή grey με εναλλαγή (alternation): 2 σωστοί και ένας λάθος τρόπος

  ..	code-block:: python
  
	>>> rexp = re.compile(r'gray|grey')
	>>> m = rexp.search('a gray cat')
	>>> if m: print('found!')
	... 
	found!

	>>> rexp = re.compile(r'gr(a|e)y')
	>>> m = rexp.search('a gray cat')
	>>> if m: print('found!')
	... 
	found!

	>>> rexp = re.compile(r'gra|ey')
	>>> m = rexp.search('a gray cat')
	>>> print(m)
	<_sre.SRE_Match object; span=(2, 5), match='gra'>
	>>> print(m.group(0))
	gra
	>>> m = rexp.search('a grey cat')
	>>> print(m)
	<_sre.SRE_Match object; span=(4, 6), match='ey'>
	>>> print(m.group(0))
	ey
      
Στο τελευταίο παράδειγμα έχουμε ταίριασμα, δεν είναι όμως αυτό που θέλουμε. **Η χρήση των παρενθέσεων είναι αναγκαία για το σωστό ταίριασμα**!
  
.. topic:: Οι παγίδες της εναλλαγής

   **Προσοχή:** Η εναλλαγή (``|``) στις υλοποιήσεις με backtracking, όταν ταιριάζουν δύο ή περισσότερες επιλογές, επιστρέφει την **πρώτη, από αριστερά προς τα δεξιά** κι όχι τη μεγαλύτερη σε μήκος όπως θα περίμενε κανείς.

   ..	code-block:: python   
   
	>>> rexp = re.compile('long|longest')
	>>> m = rexp.search('longest')
	>>> print(m.group(0))
	long
   
Χρήση της τελείας ``.`` για να ταιριάξουμε οτιδήποτε (εκτός από newline! Για να ταιριάξετε και το newline στο re.compile() προσθέστε το επιπλέον όρισμα ``re.DOTALL``)

  ..	code-block:: python
  
	>>> rexp = re.compile('a.c')
	>>> m = rexp.search('abc')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 3), match='abc'>
	>>> m = rexp.search('acb')
	>>> print(m)
	None
	>>> m = rexp.search('a\nc')
	>>> print(m)
	None

  ..	code-block:: python
  
	>>> rexp = re.compile('a.c',re.DOTALL)
	>>> m = rexp.search('a\nc')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 3), match='a\nc'>
	
Προαιρετικό: ``color`` ή ``colour``;

  ..	code-block:: python
  
	>>> rexp = re.compile('colou?r')
	>>> m = rexp.search('color')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 5), match='color'>
	>>> m = rexp.search('colour')
	>>> print(m)
	<_sre.SRE_Match object; span=(0, 6), match='colour'>

.. topic:: Ποιο είναι το προαιρετικό;

   **Προσοχή:** Το προαιρετικό εφαρμόζεται στον **έναν χαρακτήρα** αριστερά από το ``?``. Αν θέλετε να είναι προαιρετικοί περισσότεροι χαρακτήρες, χρησιμοποιήστε παρενθέσεις:

    ..	code-block:: python
	  
		>>> rexp = re.compile('col(ou)?r')
		>>> m = rexp.search('colour')
		>>> print(m)
		<_sre.SRE_Match object; span=(0, 6), match='colour'>
		>>> m = rexp.search('colr')
		>>> print(m)
		<_sre.SRE_Match object; span=(0, 4), match='colr'>   
   
