.. image:: ../by-sa.png
   :width: 80px
   :alt: Creative Commons Attribution-ShareAlike 4.0 International License

####################################
Λεκτικοί αναλυτές με το module plex
####################################

.. rubric:: Γιατί ένα νέο module λεκτικού αναλυτή;

Επιστρέφοντας στην πλήρη λεκτική ανάλυση πηγαίου κώδικα, χρειαζόμαστε κώδικα που αναλύει **όλο το κείμενο εισόδου**: δεν ψάχνουμε μόνο για μεμονωμένα ταιριάσματα, πρέπει να αναγνωρίζουμε τα πάντα, σε μη επικαλυπτόμενα ταιριάσματα.

Η λειτουργία αυτή θα μπορούσε θεωρητικά να επιτευχθεί με τα εργαλεία που έχουμε ήδη στη διάθεσή μας, τις κανονικές εκφράσεις της Python. Θα μπορούσαμε να κατασκευάσουμε κανονικές εκφράσεις, μία για κάθε είδος token που αναγνωρίζουμε, και να τις συνδυάσουμε σε μια μεγαλύτερη με εναλλαγές (``|``). Στη συνέχεια, με τη βοήθεια διαφορετικών groups θα ανιχνεύαμε τι έχει ταιριάξει και θα επιστρέφαμε το κατάλληλο token. Η διαδικασία θα ήταν επαναληπτική, μέχρι να εξαντληθεί όλος ο πηγαίος κώδικας.

Αυτή τη λειτουργία παρέχει το module ``plex``, με έναν πιο απλό και αντικειμενοστρεφή τρόπο.

.. rubric:: Διαφορές με τις κανονικές εκφράσεις

Το plex υλοποιεί τη μηχανή ταιριάσματος με ντετερμινιστικό αυτόματο (DFA), χωρίς backtracking. Αυτό σημαίνει ότι δεν έχετε στη διάθεσή σας μη-άπληστους τελεστές ή backreferences, από την άλλη πλευρά όμως η απόδοση είναι ντετερμινιστική και δεν εξαρτάται από το πώς θα γράψουμε το σχέδιο ταιριάσματος ενώ εγγυημένα επιστρέφεται πάντοτε το μεγαλύτερο ταίριασμα.

.. topic:: Προσοχή: εργασία σε virtual environment

  Θα πρέπει να έχετε εγκαταστήσει το module plex σε ένα virtual environment, το οποίο θα πρέπει να είναι ενεργοποιημένο πριν συνεχίσετε. Για περισσότερα δείτε τις οδηγίες για την :ref:`εγκατάσταση και χρήση virtual environments <python-venv-ref>` στην Python.

Χρήση του module plex
======================
Στη συνέχεια περιγράφονται τα βασικά βήματα για τη χρήση του ``plex``.

1. Κάνετε import το plex

   .. code-block:: python
	
	import plex

2. Δημιουργήστε ένα *lexicon* με ζευγάρια (pattern,action). Με τον τρόπο αυτόν λέτε στο plex τι θέλετε να αναγνωρίσετε και τι πρέπει να επιστρέφεται κάθε φορά

   .. code-block:: python
   
    lexicon = plex.Lexicon([
        (plex.Str("abc"),"ABC_TOKEN"),
        (plex.Str("123"),"123_TOKEN"),
        (plex.Rep1(plex.Any(" \t\n")),plex.IGNORE)
      ])   

3. Ανοίξτε το αρχείο εισόδου και δημιουργήστε έναν *scanner* (λεκτικό αναλυτή) για το lexicon που φτιάξατε προηγουμένως.

   .. code-block:: python

    with open("plex1.txt","r") as fp:
        scanner = plex.Scanner(lexicon,fp)

4. Διαβάστε επαναληπτικά τo token,lexeme που επιστρέφει ο scanner μέχρι να φτάσετε στο τέλος του κειμένου

   .. code-block:: python
   
        while True:
            token,matched = scanner.read()
            if not token: break	# reached end-of-text (EOT)
            print(token,matched)	

Το πλήρες πρόγραμμα φαίνεται στη συνέχεια. Το συγκεκριμένο παράδειγμα αναγνωρίζει τις ακολουθίες ``abc`` και ``123``, επιστρέφοντας τα ``ABC_TOKEN`` και ``123_TOKEN`` αντίστοιχα. Επίσης αναγνωρίζονται ακολουθίες από ένα ή περισσότερα κενά, tabs και newlines, τα οποία όμως αγνοούνται (ειδική σταθερά ``plex.IGNORE``):

.. code-block:: python

	import plex

	# the scanner lexicon - argument is a list of (pattern,action ) tuples
	lexicon = plex.Lexicon([
		(plex.Str("abc"),"ABC_TOKEN"),
		(plex.Str("123"),"123_TOKEN"),
		(plex.Rep1(plex.Any(" \t\n")),plex.IGNORE)
		])

	with open("plex1.txt","r") as fp:

		scanner = plex.Scanner(lexicon,fp)

		while True:
			token,matched = scanner.read()
	
			if not token: break	# reached end-of-text (EOT)
	
			print(token,matched)
			
Το αρχείο κειμένου εισόδου (``plex1.txt``) περιέχει π.χ.:

::

	abc 123 abc 
	123 abc
	abc123

Plex patterns
==============
Αν S, S1, S2 είναι strings, και Β, Ε χαρακτήρες, μπορούν να κατασκευαστούν τα εξής patterns ταιριάσματος:

================	================================================================
Str(S)				ταιριάζει το string S
Str(S1,S2,..)		ταιριάζει ένα από τα S1, S2, .. 
Any(S)   			ταιριάζει κάθε έναν από τους χαρακτήρες του S
AnyBut(S) 			ταιριάζει κάθε χαρακτήρα που δεν ανήκει στο S
AnyChar   			ταιριάζει κάθε μονό χαρακτήρα (και το newline)
Empty        		ταιριάζει το κενό string
Bol,Eol,Eof   		ταιριάζει στην αρχή/τέλος γραμμής και τέλος κειμένου
Range('BE') 		ταιριάζει περιοχές από το Β έως το Ε (και πολλαπλές π.χ. 'AZaz')
================	================================================================

Επίσης, αν P, P1, P2 είναι patterns που έχουν ήδη κατασκευαστεί, μπορούν να γίνουν οι εξής συνδυασμοί:

=====================	=====================================================
P1+P2 ή Seq(P1,P2)		το P1 ακολουθούμενο από το P2
P1|P2 ή Alt(P1,P2)		είτε το P1 είτε το P2 (εναλλαγή)
Opt(P) 					0 ή 1 φορά το P (προαιρετικό)
Rep(P)  	 			0 ή περισσότερες φορές το P
Rep1(P) 				1 ή περισσότερες φορές το P
NoCase(P)  Case(P)		το P, αγνοώντας (ή λαμβάνοντας υπ'όψη) κεφαλαία-μικρά
=====================	=====================================================

(για την πλήρη τεκμηρίωση του plex δείτε το https://pythonhosted.org/plex/) 

Παράδειγμα: λέξεις και αριθμοί
==============================
Στο επόμενο περιγράφεται λεκτικός αναλυτής με τη βοήθεια του plex, ο οποίος αναγνωρίζει

- *Λέξεις:* συνεχόμενες σειρές από λατινικά γράμματα (κεφαλαία-πεζά)
- *Αριθμούς:* συνεχόμενες σειρές από ψηφία (0 έως 9).
- Κενά, tabs, newlines που αγνοούνται.

Παρατηρήστε πώς μπορούμε να αναθέσουμε αντικείμενα ταιριάσματος σε μεταβλητές, τις οποίες χρησιμοποιούμε αργότερα σε πιο σύνθετα ταιριάσματα ή μέσα στο lexicon του plex. Έτσι ο κώδικάς μας γίνεται πολύ πιο ευανάγνωστος!

.. code-block:: python

	import plex

	# define patterns
	letter = plex.Range("AZaz")
	digit = plex.Range("09")

	word = plex.Rep1(letter)
	number = plex.Rep1(digit)

	# the scanner lexicon - constructor argument is a list of (pattern,action ) tuples
	lexicon = plex.Lexicon([
		(word,"WORD_TOKEN"),
		(number,"NUMBER_TOKEN"),
		(plex.Rep1(plex.Any(" \t\n")),plex.IGNORE)
		])

	with open("words-numbers.txt","r") as fp:

		scanner = plex.Scanner(lexicon,fp)

		while True:
			token,matched = scanner.read()
	
			if not token: break	# reached end-of-text (EOT)
	
			print(token,matched)	
		
Το αρχείο εισόδου ``words-numbers.txt`` μπορεί π.χ. να περιέχει τα εξής:

::

	1234 567abcD 9ac45 2333
	lKJ78 a b 09

