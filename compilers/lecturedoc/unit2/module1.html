
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Κανονικές εκφράσεις &#8212; Compiler Labs Doc 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/mytheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Παράρτημα Α: Πληροφορίες για την Python3" href="../appendix-python/module1.html" />
    <link rel="prev" title="Εισαγωγή στη λεκτική ανάλυση" href="../unit1/module1.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<div class="pageheader">
     <img src=../_static/banner.gif alt="mistral"/>
     <div>
        <h4>Τμήμα Πληροφορικής - Ιόνιο Πανεπιστήμιο</h4>
        <h2>Μεταγλωττιστές</h2>
        <h4>Εαρινό Εξάμηνο 2019-20</h4>        
        <h5>Μ.Στεφανιδάκης</h5>
      </div>    
</div>


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <a class="reference internal image-reference" href="../_images/by-sa3.png"><img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="../_images/by-sa3.png" style="width: 80px;" /></a>
<div class="section" id="id1">
<h1>Κανονικές εκφράσεις<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Στην ενότητα αυτή παρουσιάζονται οι κανονικές εκφράσεις (regular expressions) και η υποστήριξή τους στην Python.</p>
<div class="section" id="python">
<h2>Κανονικές εκφράσεις και Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h2>
<p>Στην Python (αλλά και σε πολλές άλλες γλώσσες προγραμματισμού) μπορούμε να φανταστούμε μια κανονική έκφραση ως μια μίνι-γλώσσα, η οποία χρησιμοποιείται για τη συγκρότηση μιας <em>μηχανής ταιριάσματος</em> (matching engine). Η μηχανή επεξεργάζεται το κείμενο εισόδου σύμφωνα με τις οδηγίες της κανονικής έκφρασης και επιστρέφει</p>
<ul class="simple">
<li><p>αν υπάρχει ταίριασμα (αληθές/ψευδές)</p></li>
<li><p>σε ποια σημεία (θέση στο κείμενο)</p></li>
<li><p>ποιο κομμάτι του κειμένου ταίριαξε με την προδιαγραφή</p></li>
<li><p>επίσης, η μηχανή μπορεί να αντικαταστήσει τα κομμάτια που ταίριαξαν, με άλλο κείμενο, αν αυτό ζητηθεί</p></li>
</ul>
<p>Η κανονική έκφραση περνά από μια διαδικασία μεταγλώττισης (compilation) και κατασκευάζεται ένα σύνολο οδηγιών για τη μηχανή ταιριάσματος. Η βασική μηχανή είναι γραμμένη σε C και πολύ γρήγορη σε εκτέλεση.</p>
<p>Η υλοποίηση του αυτομάτου που αντιστοιχεί στην κανονική έκφραση υλοποιείται μέσω backtracking. Αυτό σημαίνει ότι οι κανονικές εκφράσεις στην Python έχουν δυνατότητες πέρα από τις μαθηματικές κανονικές εκφράσεις, αλλά ταυτόχρονα απαιτείται προσοχή στον τρόπο κατασκευής της κανονικής έκφρασης: η απόδοση εξαρτάται από το πώς είναι γραμμένη.</p>
<div class="topic">
<p class="topic-title">Οι κανονικές εκφράσεις δεν είναι πάντοτε η λύση.</p>
<p>Η χρήση των κανονικών εκφράσεων είναι δύσκολη για τους μη πεπειραμένους και πρέπει να γίνεται με προσοχή. Εξετάστε αν μπορείτε να λύσετε το πρόβλημά σας με πιο απλό τρόπο πριν καταφύγετε στη λύση των κανονικών εκφράσεων.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Some people, when confronted with a problem, think &#39;I know, I&#39;ll use
regular expressions.&#39; Now they have two problems.
         -- Jamie Zawinski, alt.religion.emacs (08/12/1997)
</pre></div>
</div>
<p>Επίσης θα πρέπει πάντοτε να θυμάστε ότι όταν ψάχνουμε <strong>συγκεκριμένα strings σταθερού μήκους</strong> μέσα σε άλλα, οι κανονικές εκφράσεις <strong>δεν είναι η λύση</strong>. Υπάρχουν πολύ πιο αποδοτικοί αλγόριθμοι αναζήτησης strings. Στην Python είναι πάντα προτιμότερο στις περιπτώσεις αυτές να χρησιμοποιούνται μέθοδοι των strings κι όχι κανονικές εκφράσεις:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abcd 123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;345&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Χρήση κανονικών εκφράσεων στην Python<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Στην Python η υλοποίηση των κανονικών εκφράσεων είναι αντικειμενοστρεφής.</p>
<p>Η υποστήριξη των regular expressions υπάρχει ενσωματωμένη στη γλώσσα, στο module <code class="docutils literal notranslate"><span class="pre">re</span></code>:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
</pre></div>
</div>
</div></blockquote>
<p>Το <code class="docutils literal notranslate"><span class="pre">import</span></code> αυτό γίνεται <strong>μια φορά</strong> στην αρχή του προγράμματός σας και επιτρέπει να χρησιμοποιήσετε όλες τις μεθόδους, τις σταθερές και τα αντικείμενα του module <code class="docutils literal notranslate"><span class="pre">re</span></code>.</p>
<p>Στη συνέχεια, μπορείτε να φτιάξετε «μηχανές ταιριάσματος» με τη βοήθεια της συνάρτησης <code class="docutils literal notranslate"><span class="pre">re.compile()</span></code>, π.χ.:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^cat&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Στο προηγούμενο παράδειγμα, η μεταβλητή <code class="docutils literal notranslate"><span class="pre">rexp</span></code> είναι η μηχανή ταιριάσματος, ένα αντικείμενο δηλαδή που μας επιτρέπει να ψάξουμε για ταιριάσματα σύμφωνα με την κανονική έκφραση <code class="docutils literal notranslate"><span class="pre">^cat</span></code>. Το αντικείμενο <strong>κατασκευάζεται άπαξ</strong> (π.χ. στην αρχή του προγράμματος). Στη συνέχεια, μπορούμε να το χρησιμοποιήσουμε <strong>όσες φορές θέλουμε</strong> για να ταιριάξουμε κείμενο:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Η μέθοδος <code class="docutils literal notranslate"><span class="pre">search()</span></code> είναι η βασική μέθοδος της μηχανής αναζήτησης <code class="docutils literal notranslate"><span class="pre">rexp</span></code> και αναζητά το σχέδιο ταιριάσματος της αντίστοιχης κανονικής έκφρασης (<code class="docutils literal notranslate"><span class="pre">^cat</span></code>) οπουδήποτε μέσα στο string <code class="docutils literal notranslate"><span class="pre">category</span></code>. Η επιστρεφόμενη τιμή στη μεταβλητή <code class="docutils literal notranslate"><span class="pre">m</span></code> περιέχει ένα «αντικείμενο ταιριάσματος» με πληροφορίες για το τι (αν) ταίριαξε στην αναζήτηση:</p>
<ul class="simple">
<li><p>Το <code class="docutils literal notranslate"><span class="pre">m</span></code> είναι <code class="docutils literal notranslate"><span class="pre">None</span></code> σε περίπτωση αποτυχίας ταιριάσματος.</p></li>
<li><p>Αν υπάρχει ταίριασμα, το <code class="docutils literal notranslate"><span class="pre">m</span></code> περιέχει μεθόδους για να λάβουμε την πληροφορία του ταιριάσματος.</p></li>
</ul>
<p>Έτσι, μπορούμε για παράδειγμα να γράψουμε:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">m</span><span class="p">:</span>   <span class="c1"># m is not None</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found! matched=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

<span class="k">else</span><span class="p">:</span>   <span class="c1"># m is None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;not found&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Το <code class="docutils literal notranslate"><span class="pre">m.group(0)</span></code> επιστρέφει το συνολικό κείμενο που ταίριαξε. Τα <em>groups</em> είναι μέρη του ταιριάσματος και θα αναλυθούν στα επόμενα.</p>
<p>Στη συνέχεια δίνεται το συνολικό προηγούμενο παράδειγμα</p>
<ul>
<li><p>Στο interactive shell της Python (αν θέλετε να το δοκιμάσετε, ξεκινήστε το interactive shell με την εντολή <code class="docutils literal notranslate"><span class="pre">python3</span></code> (ή <code class="docutils literal notranslate"><span class="pre">python</span></code>) στη κονσόλα/τερματικό/command prompt του λειτουργικού σας. Θυμηθείτε ότι δεν πληκτρολογείτε τα <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code>):</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;I see a cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;cat&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">cat</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Ως αυτόνομο αρχείο εκτέλεσης (τρέξτε με <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">yourfile.py</span></code> ή <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">yourfile.py</span></code>):</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^cat&#39;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found! matched=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;not found&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>Στις επόμενες παραγράφους αναφέρονται <strong>μερικά μόνο</strong> από τα εργαλεία της Python για κανονικές εκφράσεις. Για την πλήρη περιγραφή του module <code class="docutils literal notranslate"><span class="pre">re</span></code>, δείτε στο <a class="reference external" href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a>.</p>
</div>
<div class="section" id="id3">
<h3>Βασικά σύμβολα κανονικών εκφράσεων<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Ο πίνακας που ακολουθεί περιέχει τα βασικά σύμβολα που χρησιμοποιούνται για την κατασκευή κανονικών εκφράσεων στην Python (<em>παρατίθενται τα σύμβολα που έχουν διδαχθεί στο εργαστήριο</em>).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">abc</span></code></p></td>
<td><p>ταιριάζει ακριβώς το γράμμα <code class="docutils literal notranslate"><span class="pre">a</span></code>, ακολουθούμενο από το <code class="docutils literal notranslate"><span class="pre">b</span></code> και μετά το <code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">a|b</span></code></p></td>
<td><p>είτε το <code class="docutils literal notranslate"><span class="pre">a</span></code>, είτε το <code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[abc]</span></code></p></td>
<td><p>character class: ένα από τα <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> ή <code class="docutils literal notranslate"><span class="pre">c</span></code> (<strong>προσοχή: ένας χαρακτήρας μόνο</strong>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[a-zA-Z]</span></code></p></td>
<td><p>όπως προηγουμένως, αλλά σε ένα πεδίο τιμών, από <code class="docutils literal notranslate"><span class="pre">a</span></code> έως και  <code class="docutils literal notranslate"><span class="pre">z</span></code> και από <code class="docutils literal notranslate"><span class="pre">A</span></code> έως και <code class="docutils literal notranslate"><span class="pre">Z</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[^ab]</span></code></p></td>
<td><p>ένας οποιοσδήποτε χαρακτήρας, <strong>εκτός από</strong> <code class="docutils literal notranslate"><span class="pre">a</span></code> ή <code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">$</span></code></p></td>
<td><p>ταιριάζει <strong>στο τέλος</strong> του string (ρυθμίζεται να ταιριάζει και στο τέλος κάθε γραμμής του string)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>ταιριάζει <strong>στην αρχή</strong> του string (ρυθμίζεται να ταιριάζει και στην αρχή κάθε γραμμής του string)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
<td><p>ένας <strong>οποιοσδήποτε</strong> χαρακτήρας εκτός από newline (ρυθμίζεται να ταιριάζει και το newline)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">?</span></code></p></td>
<td><p>0 ή 1 φορά ο χαρακτήρας που προηγείται</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>0 ή περισσότερες φορές ο χαρακτήρας που προηγείται</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p>1 ή περισσότερες φορές ο χαρακτήρας που προηγείται</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">{n}</span></code> <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">n</span></code> φορές / από <code class="docutils literal notranslate"><span class="pre">n</span></code> έως <code class="docutils literal notranslate"><span class="pre">m</span></code> φορές ο χαρακτήρας που προηγείται</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\b</span></code></p></td>
<td><p>ταιριάζει στην αρχή και στο τέλος μιας λέξης</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\w</span></code> <code class="docutils literal notranslate"><span class="pre">\W</span></code></p></td>
<td><p>οποιοσδήποτε αλφαριθμητικός / μη αλφαριθμητικός χαρακτήρας</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\s</span></code> <code class="docutils literal notranslate"><span class="pre">\S</span></code></p></td>
<td><p>οποιοσδήποτε whitespace / μη whitespace χαρακτήρας</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">*?</span></code> <code class="docutils literal notranslate"><span class="pre">+?</span></code> <code class="docutils literal notranslate"><span class="pre">??</span></code></p></td>
<td><p>μη άπληστες (non-greedy) μορφές των <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> και <code class="docutils literal notranslate"><span class="pre">?</span></code> (μόνο υλοποιήσεις backtracking)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">()</span></code></p></td>
<td><p>group ομαδοποίησης τμημάτων μιας κανονικής έκφρασης, συγκρατούν το κείμενο που ταιριάζει στο τμήμα (μόνο υλοποιήσεις backtracking)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\1</span></code> <code class="docutils literal notranslate"><span class="pre">\2</span></code> κλπ</p></td>
<td><p>backreferences: μέσα στην κανονική έκφραση αντικαθίστανται από το τι έχει ταιριάξει ως τώρα στο αντίστοιχο group (μόνο υλοποιήσεις backtracking)</p></td>
</tr>
</tbody>
</table>
<p>Με βάση τα πιο πάνω μπορούμε να συντάξουμε πιο σύνθετες κανονικές εκφράσεις, συνδυάζοντας πολλές μικρότερες.</p>
</div>
<div class="section" id="id4">
<h3>Παραδείγματα<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Παραδείγματα με τα σύμβολα που έχουν διδαχθεί έως τώρα στο εργαστήριο. Τα παραδείγματα δίνονται στο interactive shell της Python, θεωρήστε ότι έχει προηγηθεί το <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">re</span></code>.</p>
<div class="topic">
<p class="topic-title">Πηγή παραδειγμάτων</p>
<p>Πολλά από τα παραδείγματα που ακολουθούν βασίζονται σε υλικό από το βιβλίο “Mastering Regular Expressions”, 2nd ed., Jeffrey E.F. Friedl, O’Reilly Media, July 2002.</p>
</div>
<div class="section" id="id5">
<h4>Στην αρχή ή στο τέλος<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Βρείτε το string <code class="docutils literal notranslate"><span class="pre">cat</span></code> στην αρχή (με το <code class="docutils literal notranslate"><span class="pre">^</span></code>) ή στο τέλος (<code class="docutils literal notranslate"><span class="pre">$</span></code>) ενός string:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;I see a cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;cat&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;cat$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;in category&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;black cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">m</span>
<span class="go">&lt;_sre.SRE_Match object; span=(6, 9), match=&#39;cat&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">found!</span>
</pre></div>
</div>
<p>Για να ταιριάξουμε ένα άδειο string, θα μπορούσαμε (θεωρητικά -δεν χρειάζεται στην πράξη!) να χρησιμοποιήσουμε το <code class="docutils literal notranslate"><span class="pre">'^$'</span></code>.</p>
</div>
<div class="section" id="id6">
<h4>Κλάσεις χαρακτήρων<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Κλάσεις χαρακτήρων με το <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Θυμηθείτε ότι μέσα στην κλάση, οι χαρακτήρες ελέγχου χάνουν το ειδικό τους νόημα και το <code class="docutils literal notranslate"><span class="pre">^</span></code> σημαίνει κάτι διαφορετικό:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;gr[ae]y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a gray cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">found!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a grey cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">found!</span>
</pre></div>
</div>
<p>Βρείτε <code class="docutils literal notranslate"><span class="pre">a</span></code> που δεν ακολουθείται από <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a[^b]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;acb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 2), match=&#39;ac&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">ac</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;ba&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Στο τελευταίο παράδειγμα βλέπουμε ότι ενώ το <code class="docutils literal notranslate"><span class="pre">a</span></code> δεν πρέπει να ακολουθείται από <code class="docutils literal notranslate"><span class="pre">b</span></code>, <strong>πρέπει όμως να ακολουθείται από κάτι άλλο</strong>.</p>
</div>
<div class="section" id="id7">
<h4>Εναλλαγή<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>Βρείτε το gray ή grey με εναλλαγή (alternation): 2 σωστοί και ένας λάθος τρόπος</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;gray|grey&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a gray cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">found!</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;gr(a|e)y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a gray cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">found!</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;gra|ey&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a gray cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(2, 5), match=&#39;gra&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">gra</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a grey cat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(4, 6), match=&#39;ey&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">ey</span>
</pre></div>
</div>
<p>Στο τελευταίο παράδειγμα έχουμε ταίριασμα, δεν είναι όμως αυτό που θέλουμε. <strong>Η χρήση των παρενθέσεων είναι αναγκαία για το σωστό ταίριασμα</strong>!</p>
<div class="topic">
<p class="topic-title">Οι παγίδες της εναλλαγής</p>
<p><strong>Προσοχή:</strong> Η εναλλαγή (<code class="docutils literal notranslate"><span class="pre">|</span></code>) στις υλοποιήσεις με backtracking, όταν ταιριάζουν δύο ή περισσότερες επιλογές, επιστρέφει την <strong>πρώτη, από αριστερά προς τα δεξιά</strong> κι όχι τη μεγαλύτερη σε μήκος όπως θα περίμενε κανείς.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;long|longest&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;longest&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">long</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>Ένας οποιοσδήποτε χαρακτήρας<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Χρήση της τελείας <code class="docutils literal notranslate"><span class="pre">.</span></code> για να ταιριάξουμε οτιδήποτε (εκτός από newline! Για να ταιριάξετε και το newline στο re.compile() προσθέστε το επιπλέον όρισμα <code class="docutils literal notranslate"><span class="pre">re.DOTALL</span></code>)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;a.c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;abc&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;acb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a</span><span class="se">\n</span><span class="s1">c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;a.c&#39;</span><span class="p">,</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;a</span><span class="se">\n</span><span class="s1">c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;a\nc&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>Προαιρετικό<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>Προαιρετικό: <code class="docutils literal notranslate"><span class="pre">color</span></code> ή <code class="docutils literal notranslate"><span class="pre">colour</span></code>;</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;colou?r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 5), match=&#39;color&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 6), match=&#39;colour&#39;&gt;</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Ποιο είναι το προαιρετικό;</p>
<p><strong>Προσοχή:</strong> Το προαιρετικό εφαρμόζεται στον <strong>έναν χαρακτήρα</strong> αριστερά από το <code class="docutils literal notranslate"><span class="pre">?</span></code>. Αν θέλετε να είναι προαιρετικοί περισσότεροι χαρακτήρες, χρησιμοποιήστε παρενθέσεις:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;col(ou)?r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 6), match=&#39;colour&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;colr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;_sre.SRE_Match object; span=(0, 4), match=&#39;colr&#39;&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="id10">
<h4>Τελεστές επανάληψης<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>Τελεστές επανάληψης: <code class="docutils literal notranslate"><span class="pre">*</span></code> (0 ή περισσότερες φορές) και <code class="docutils literal notranslate"><span class="pre">+</span></code> (1 ή περισσότερες φορές). Οι τελεστές αυτοί εφαρμόζονται σε ό,τι βρίσκεται στα αριστερά τους (για να τους εφαρμόσετε σε πάνω από έναν χαρακτήρα χρησιμοποιήστε παρενθέσεις). Εξ’ ορισμού οι τελεστές επανάληψης είναι <strong>άπληστοι</strong> (greedy): προσπαθούν να ταιριάξουν <em>όσο το δυνατόν περισσότερο</em> κείμενο. Προσοχή με τους τελεστές επανάληψης: μην καταλήξετε σε κανονικές εκφράσεις που δεν επιλέγουν τίποτα (π.χ. <code class="docutils literal notranslate"><span class="pre">re.compile('a*')</span></code>!</p>
<p>Στο παράδειγμα που ακολουθεί η κανονική έκφραση ταιριάζει σειρές από ψηφία <code class="docutils literal notranslate"><span class="pre">0</span></code> έως <code class="docutils literal notranslate"><span class="pre">9</span></code>, οποιουδήποτε μήκους (ένα ή περισσότερα ψηφία):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[0-9]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;abc1234def&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">1234</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>Ολόκληρες λέξεις<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Εάν θέλουμε στο προηγούμενο παράδειγμα να έχουμε ταιριάσματα <em>μόνο σε ολόκληρες λέξεις</em>, μπορούμε να χρησιμοποιήσουμε το σύμβολο <code class="docutils literal notranslate"><span class="pre">\b</span></code> που ταιριάζει στην αρχή και στο τέλος λέξεων (στις εναλλαγές αλφαριθμητικών και μη αλφαριθμητικών χαρακτήρων):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b[0-9]+\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;abc1234def&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;1234&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">1234</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Τα «ωμά» (raw) strings στην Python</p>
<p>Στο προηγούμενο παράδειγμα παρατηρήστε τη χρήση του <code class="docutils literal notranslate"><span class="pre">r'....'</span></code> στο string της κανονικής έκφρασης. Στις σταθερές string η Python (όπως και η C) αντικαθιστά χαρακτήρες με escape <code class="docutils literal notranslate"><span class="pre">\</span></code> με άλλα σύμβολα. Ο πιο γνωστός συνδυασμός είναι το <code class="docutils literal notranslate"><span class="pre">\n</span></code> που αντικαθίσταται από έναν χαρακτήρα newline.</p>
<p>Όταν όμως περνάμε το <code class="docutils literal notranslate"><span class="pre">\b</span></code> στη συνάρτηση <code class="docutils literal notranslate"><span class="pre">re.compile()</span></code> <strong>δεν θέλουμε</strong> η Python να το αντικαταστήσει με κάτι άλλο (με τον χαρακτήρα backspace, για την ακρίβεια): το escape <code class="docutils literal notranslate"><span class="pre">\b</span></code> προορίζεται για τις κανονικές εκφράσεις. Η χρήση του «ωμού» string literal με το <code class="docutils literal notranslate"><span class="pre">r'....'</span></code> λέει στην Python να περάσει το string ως έχει, χωρίς αντικαταστάσεις των escapes, στη συνάρτηση.</p>
</div>
<p>Στο επόμενο παράδειγμα αναζητούμε κλασματικούς αριθμούς με ακέραιο και δεκαδικό μέρος. Παρατηρήστε ότι για να ταιριάξουμε την υποδιαστολή πρέπει να χρησιμοποιήσουμε τον συνδυασμό <code class="docutils literal notranslate"><span class="pre">\.</span></code> γιατί η τελεία <code class="docutils literal notranslate"><span class="pre">.</span></code> από μόνη της είναι ειδικό σύμβολο στις κανονικές εκφράσεις!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9]+\.[0-9]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;1234.567&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">1234.567</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">Τα ταιριάσματα είναι πάντα κείμενο</p>
<p>Σε μια πραγματική εφαρμογή ό,τι έχει ταιριάξει μέσω κανονικών εκφράσεων προορίζεται για περαιτέρω επεξεργασία. Στο προηγούμενο παράδειγμα, ο κλασματικός αριθμός μπορεί π.χ. να προορίζεται για αριθμητικές πράξεις. Το <code class="docutils literal notranslate"><span class="pre">m.group(0)</span></code> όμως είναι string, οπότε πρέπει πρώτα να το μετατρέψετε στην κατάλληλη μορφή:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9]+\.[0-9]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;1234.567&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">number</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">... </span>  <span class="n">number</span> <span class="o">+=</span> <span class="mf">1.23</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1235.797</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="groups">
<h4>Μέρη ταιριασμάτων (groups)<a class="headerlink" href="#groups" title="Permalink to this headline">¶</a></h4>
<p>Τι είναι τα <em>groups</em>; Στις κανονικές εκφράσεις οι παρενθέσεις παίζουν ειδικό ρόλο, ομαδοποιώντας υποσύνολα της κανονικής έκφρασης. Επιπλέον, η μηχανή ταιριάσματος θυμάται τι ταίριαξε σε κάθε group:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([0-9]+)\.([0-9]+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;12.54&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">12.54</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">54</span>
</pre></div>
</div>
<p>Στο προηγούμενο παράδειγμα, οι παρενθέσεις γύρω από το ακέραιο και το δεκαδικό μέρος ορίζουν δύο πρόσθετα groups (<code class="docutils literal notranslate"><span class="pre">group(1)</span></code> και <code class="docutils literal notranslate"><span class="pre">group(2)</span></code>), εκτός από το <code class="docutils literal notranslate"><span class="pre">group(0)</span></code> που περιλαμβάνει όλο το κείμενο που έχει ταιριάξει.</p>
<p>Η αρίθμηση των πρόσθετων groups αρχίζει από το 1, κάθε φορά που ανοίγει μια παρένθεση, προχωρώντας από αριστερά προς τα δεξιά. Αυτό ισχύει ακόμα και όταν οι παρενθέσεις είναι μέσα σε άλλες.</p>
<p>Αν ένα σετ παρενθέσεων έχει μπει μόνο για την εξυπηρέτηση του <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> κλπ και δεν θέλουμε τη συγκράτηση της τιμής του group, μπορούμε να χρησιμοποιήσουμε το <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>. Στη μορφή αυτή οι παρενθέσεις δεν ορίζουν νέο group.</p>
</div>
</div>
<div class="section" id="id12">
<h3>Η απληστία των τελεστών * και +<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>Όπως ήδη γνωρίζουμε, οι τελεστές <code class="docutils literal notranslate"><span class="pre">*</span></code> και <code class="docutils literal notranslate"><span class="pre">+</span></code> (αλλά και ο <code class="docutils literal notranslate"><span class="pre">?</span></code>) είναι <em>άπληστοι</em> (greedy). Αυτό σημαίνει ότι η μηχανή ταιριάσματος των κανονικών εκφράσεων, όταν προσπαθεί να ικανοποιήσει κάποιον από τους τελεστές αυτούς και έχει και άλλες επιλογές</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>θα προτιμήσει να συνεχίσει να ταιριάζει με τον τελεστή</strong></p></li>
<li><p>παρά να σταματήσει και να προχωρήσει στο επόμενο τμήμα της κανονικής έκφρασης.</p></li>
</ul>
</div></blockquote>
<div class="topic">
<p class="topic-title">Τι συμβαίνει εδώ;</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^.*([0-9]+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Copyright 2003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Γιατί δεν μπήκε όλο το <code class="docutils literal notranslate"><span class="pre">2003</span></code> μέσα στο group(1); Το <code class="docutils literal notranslate"><span class="pre">*</span></code> είναι άπληστο και καταναλώνει όλο το string. Στη συνέχεια αποδεσμεύει  το <code class="docutils literal notranslate"><span class="pre">3</span></code> για να επιτρέψει και στο <code class="docutils literal notranslate"><span class="pre">+</span></code> να πετύχει ταίριασμα. Η διαδικασία σταματά εδώ και ποτέ δεν δίνεται η ευκαιρία στο <code class="docutils literal notranslate"><span class="pre">+</span></code> να ταιριάξει όλο το <code class="docutils literal notranslate"><span class="pre">2003</span></code>.</p>
</div>
<p>Η απληστία των τελεστών <code class="docutils literal notranslate"><span class="pre">*</span></code> και <code class="docutils literal notranslate"><span class="pre">+</span></code> είναι η επιθυμητή συμπεριφορά. Μερικές φορές όμως πρέπει να είμαστε προσεκτικοί για να επιτύχουμε αυτό που θέλουμε. Στο επόμενο παράδειγμα προσπαθούμε <strong>με λάθος τρόπο</strong> να ταιριάξουμε ετικέτες (tags) HTML:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;.+&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt; text&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt;</span>
</pre></div>
</div>
<p>Η απάντηση <code class="docutils literal notranslate"><span class="pre">&lt;b&gt;is&lt;/b&gt;</span> <span class="pre">a</span> <span class="pre">&lt;em&gt;HTML&lt;/em&gt;</span></code> διαφέρει από την αναμενόμενη, το πρώτο <code class="docutils literal notranslate"><span class="pre">&lt;b&gt;</span></code> δηλαδή. Αυτό συμβαίνει γιατί ο τελεστής <code class="docutils literal notranslate"><span class="pre">+</span></code> θα συνεχίσει να ταιριάζει χαρακτήρες έως το τέλος του string και στη συνέχεια μέσω backtracking θα αρχίσει να αποδεσμεύει χαρακτήρες προς τα πίσω μέχρι να μπορέσει και το <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> να ταιριάξει. Έτσι η απάντηση θα περιλαμβάνει τα πάντα από το πρώτο μέχρι το τελευταίο tag.</p>
<p>Πώς μπορεί να βρεθεί η σωστή λύση; Στην περίπτωση του παραδείγματος υπάρχουν <strong>δύο τρόποι</strong>. Ο πρώτος τρόπος αποφεύγει εντελώς τη χρήση του  «οτιδήποτε» (<code class="docutils literal notranslate"><span class="pre">.</span></code>, τελεία) με τον τελεστή <code class="docutils literal notranslate"><span class="pre">+</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;[^&gt;]+&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt; text&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;b&gt;</span>
</pre></div>
</div>
<p>Η προηγούμενη μέθοδος είναι <strong>η βέλτιστη γιατί δεν εκτελεί καθόλου backtracking</strong>. Θα πρέπει πάντα να την προτιμάτε όταν ψάχνετε <em>μέχρι να βρείτε</em> έναν συγκεκριμένο χαρακτήρα (όπως εδώ το <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>).</p>
<p>Η δεύτερη μέθοδος είναι διαθέσιμη μόνο όταν οι κανονικές εκφράσεις υλοποιούνται με backtracking (στις περισσότερες γλώσσες προγραμματισμού δηλαδή). Εδώ χρησιμοποιούμε τη <em>μη-άπληστη</em> (lazy) μορφή των τελεστών επανάληψης (συμβολίζεται με τα <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code> και <code class="docutils literal notranslate"><span class="pre">??</span></code>). Η μη-άπληστη μορφή <strong>προτιμάει να σταματήσει παρά να συνεχίσει το ταίριασμα</strong>, ακόμα κι αν έχει τη δυνατότητα:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;.+?&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt; text&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;b&gt;</span>
</pre></div>
</div>
<p>Στο παράδειγμα, ο μη-άπληστος τελεστής <code class="docutils literal notranslate"><span class="pre">+?</span></code>, αφού ταιριάξει το <code class="docutils literal notranslate"><span class="pre">b</span></code> από το πρώτο <code class="docutils literal notranslate"><span class="pre">&lt;b&gt;</span></code> tag, θα παραιτηθεί από τη συνέχεια, επιτρέποντας και στο <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> να ταιριάξει.</p>
<p>Η δεύτερη μέθοδος ίσως εκτελέσει περιορισμένο backtracking, οπότε αν έχουμε την ευχέρεια προτιμάμε την πρώτη. Μερικές φορές όμως θέλουμε να προχωρήσουμε επιλέγοντας <em>μέχρι μια συγκεκριμένη ομάδα χαρακτήρων</em> (όχι μέχρι έναν μεμονωμένο χαρακτήρα). Τότε χρησιμοποιούμε μια μορφή μη-άπληστου τελεστή.</p>
<p>Στο επόμενο παράδειγμα θέλουμε να ταιριάξουμε σχόλια HTML, οτιδήποτε δηλαδή βρίσκεται μεταξύ <code class="docutils literal notranslate"><span class="pre">&lt;!--</span></code> και <code class="docutils literal notranslate"><span class="pre">--&gt;</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;!--.*?--&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; &lt;!--a &lt;em&gt;--HTML--&lt;/em&gt;--&gt; text&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!--a &lt;em&gt;--HTML--&lt;/em&gt;--&gt;</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">«Καταστροφικό» backtracking</p>
<p>Η παράθεση πολλαπλών <code class="docutils literal notranslate"><span class="pre">*</span></code> και <code class="docutils literal notranslate"><span class="pre">+</span></code> οδηγεί συχνά στην αποτυχία ταιριάσματος ή ακόμα και στην αποτυχία της ίδιας της μηχανής αναζήτησης. Έτσι, <strong>πρέπει να γίνεται με προσοχή</strong>. Δείτε για παράδειγμα το εξής (ακραίο) παράδειγμα, όπου η αναζήτηση ταιριάσματος που δεν υπάρχει, οδηγεί σε μη πρακτικό χρόνο εκτέλεσης:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(=+=+)+X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;============================================&#39;</span><span class="p">)</span>
<span class="go">^CTraceback (most recent call last):</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="nc">KeyboardInterrupt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(==)+X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;============================================&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Αυτό συμβαίνει διότι η διαδικασία backtracking έχει να εξετάσει <strong>εκθετικά μεγάλο αριθμό περιπτώσεων</strong> προσπαθώντας να βρει ένα ταίριασμα!</p>
</div>
</div>
<div class="section" id="finditer">
<h3>Η μέθοδος finditer()<a class="headerlink" href="#finditer" title="Permalink to this headline">¶</a></h3>
<p>Μέχρι τώρα έχουμε δουλέψει μόνο με τη βασική μέθοδο <code class="docutils literal notranslate"><span class="pre">search()</span></code> των κανονικών εκφράσεων. Στη συνέχεια παρουσιάζεται η παραπλήσια μέθοδος <code class="docutils literal notranslate"><span class="pre">finditer()</span></code> η οποία επιστρέφει διαδοχικά αντικείμενα ταιριάσματος (match objects) <em>για όλα τα μη επικαλυπτόμενα ταιριάσματα</em> της κανονικής έκφρασης σε ένα string:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;[^&gt;]+&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">rexp</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt; text&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;b&gt;</span>
<span class="go">&lt;/b&gt;</span>
<span class="go">&lt;em&gt;</span>
<span class="go">&lt;/em&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Όπως φαίνεται στο προηγούμενο παράδειγμα, η <code class="docutils literal notranslate"><span class="pre">finditer()</span></code> χρησιμοποιείται σε επαναληπτικές δομές <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">...</span></code> και σε κάθε επανάληψη επιστρέφει ένα αντικείμενο ταιριάσματος ακριβώς όπως και η <code class="docutils literal notranslate"><span class="pre">search()</span></code>.</p>
</div>
<div class="section" id="sub">
<h3>Η μέθοδος sub()<a class="headerlink" href="#sub" title="Permalink to this headline">¶</a></h3>
<p>Η μέθοδος <code class="docutils literal notranslate"><span class="pre">sub()</span></code> των κανονικών εκφράσεων χρησιμοποιείται για την εύρεση (μη επικαλυπτόμενων) ταιριασμάτων και την αντικατάστασή τους με κάτι διαφορετικό. Στην πιο απλή περίπτωση, κάθε ταίριασμα αντικαθίσταται με ένα σταθερό string. Το επόμενο παράδειγμα αντικαθιστά κάθε ετικέτα HTML με το string <code class="docutils literal notranslate"><span class="pre">&#64;&#64;&#64;</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&lt;[^&gt;]+&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newtext</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;@@@&#39;</span><span class="p">,</span><span class="s1">&#39;this &lt;b&gt;is&lt;/b&gt; a &lt;em&gt;HTML&lt;/em&gt; text&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">newtext</span><span class="p">)</span>
<span class="go">this @@@is@@@ a @@@HTML@@@ text</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Η μέθοδος <code class="docutils literal notranslate"><span class="pre">sub()</span></code> μπορεί να χρησιμοποιήσει <strong>backreferences</strong> μέσα στο string αντικατάστασης. Τα backreferences δίνουν τη δυνατότητα στις κανονικές εκφράσεις <strong>να έχουν πρόσβαση στα groups που έχουν ήδη ταιριάξει</strong>. Η δυνατότητα αυτή υπάρχει μόνο σε υλοποιήσεις με backtracking και είναι ένα σημείο που κάνει
τις «προγραμματιστικές» κανονικές εκφράσεις να διαφέρουν από τις «μαθηματικές». Τα backreferences χρησιμοποιούν τον συμβολισμό <code class="docutils literal notranslate"><span class="pre">\n</span></code> όπου <code class="docutils literal notranslate"><span class="pre">n</span></code> ο αριθμός του επιθυμητού group.</p>
<p>Δείτε το επόμενο παράδειγμα, όπου ανιχνεύονται διπλές ίδιες λέξεις (με λατινικούς χαρακτήρες) και αντικαθίστανται από την πρώτη λέξη μόνο:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b([a-z]+)\s+\1\b&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span><span class="s1">&#39;This this is a a known fact.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">This is a known fact.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Στο προηγούμενο παράδειγμα, η κανονική έκφραση στο <code class="docutils literal notranslate"><span class="pre">re.compile()</span></code> ταιριάζει στο σημείο <code class="docutils literal notranslate"><span class="pre">\1</span></code> ό,τι έχει <strong>ήδη ταιριάξει</strong> στο group <code class="docutils literal notranslate"><span class="pre">([a-z]+)</span></code>, άρα ανιχνεύει ίδιες λέξεις χωρισμένες από χαρακτήρες whitespace. Το πρόσθετο όρισμα <code class="docutils literal notranslate"><span class="pre">re.IGNORECASE</span></code> επιτρέπει ταιριάσματα ανεξάρτητα από κεφαλαία-πεζά.</p>
<p>Στη <code class="docutils literal notranslate"><span class="pre">sub()</span></code>, το ίδιο backreference <code class="docutils literal notranslate"><span class="pre">\1</span></code> χρησιμοποιείται για να αντικαταστήσει όλο το κείμενο που ταίριαξε (τις δύο όμοιες λέξεις) με το περιεχόμενο του group(1) (της πρώτης λέξης, δηλαδή). Θυμηθείτε ότι, εφόσον υπάρχει <code class="docutils literal notranslate"><span class="pre">\</span></code> μέσα στην κανονική έκφραση, <strong>αλλά και στο string αντικατάστασης</strong> της <code class="docutils literal notranslate"><span class="pre">sub()</span></code> θα πρέπει να χρησιμοποιήσετε raw string (<code class="docutils literal notranslate"><span class="pre">r'...'</span></code>).</p>
<p>Η <code class="docutils literal notranslate"><span class="pre">sub()</span></code>, στην πιο ευέλικτη εκδοχή χρήσης της, μπορεί να δεχτεί μια συνάρτηση («callback») ως όρισμα αντικατάστασης. Στην περίπτωση αυτή, για κάθε μη επικαλυπτόμενο ταίριασμα, η συνάρτηση θα κληθεί έχοντας ως όρισμα ένα αντικείμενο ταιριάσματος (match object). Ό,τι επιστρέψει η συνάρτηση είναι αυτό που θα αντικαταστήσει το κάθε ταίριασμα.</p>
<p>Με τη χρήση συνάρτησης callback παρέχεται η δυνατότητα εκτέλεσης πολύ σύνθετων αντικαταστάσεων. Στο παράδειγμα που ακολουθεί, ανιχνεύουμε αριθμούς με ακέραιο και κλασματικό μέρος και αντιμεταθέτουμε τα μέρη αυτά (το ακέραιο γίνεται κλασματικό και αντίστροφα):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cb</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([0-9]+)\.([0-9]+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newtext</span> <span class="o">=</span> <span class="n">rexp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span><span class="s1">&#39;abcd 123.456 def 99.11 23&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">newtext</span><span class="p">)</span>
<span class="go">abcd 456.123 def 11.99 23</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>Ασκήσεις<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Κατασκευάστε κανονική έκφραση για την αναγνώριση έγκυρων μορφών 24ωρης ώρας (<code class="docutils literal notranslate"><span class="pre">00:00</span></code> έως <code class="docutils literal notranslate"><span class="pre">23:59</span></code>) με τη βοήθεια των <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> και <code class="docutils literal notranslate"><span class="pre">\b</span></code>.</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Η ώρα μπορεί να εκφράζεται με ένα ή δύο ψηφία (π.χ. <code class="docutils literal notranslate"><span class="pre">3:45</span></code> αλλά και <code class="docutils literal notranslate"><span class="pre">03:45</span></code>).</p></li>
<li><p>Τα λεπτά θα έχουν πάντα δύο ψηφία.</p></li>
<li><p>Κάθε άκυρη μορφή ώρας θα απορρίπτεται (π.χ. <code class="docutils literal notranslate"><span class="pre">31:13</span></code> ή <code class="docutils literal notranslate"><span class="pre">9:72</span></code>).</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Γράψτε κανονική έκφραση που αναγνωρίζει κλασματικούς αριθμούς, οποιουδήποτε μήκους</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Στις μορφές <code class="docutils literal notranslate"><span class="pre">123.456</span></code>, <code class="docutils literal notranslate"><span class="pre">123.</span></code> και <code class="docutils literal notranslate"><span class="pre">.456</span></code>.</p></li>
<li><p>Προσοχή μην καταλήξετε σε κανονική έκφραση που δεν επιλέγει τίποτα ή επιλέγει μόνο την τελεία!</p></li>
<li><p>Θυμηθείτε ότι θα πρέπει να γράψετε την τελεία με escape ως <code class="docutils literal notranslate"><span class="pre">\.</span></code> (αλλιώς έχει ειδική έννοια).</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Γράψτε κανονική έκφραση που ταιριάζει</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Κλασματικούς αριθμούς στη μορφή <code class="docutils literal notranslate"><span class="pre">ΧΧΧ</span></code> ή <code class="docutils literal notranslate"><span class="pre">ΧΧΧ.ΥΥΥ</span></code> (τα <code class="docutils literal notranslate"><span class="pre">Χ</span></code> και <code class="docutils literal notranslate"><span class="pre">Υ</span></code> είναι τα  ψηφία <code class="docutils literal notranslate"><span class="pre">0</span></code> έως <code class="docutils literal notranslate"><span class="pre">9</span></code> σε οποιοδήποτε πλήθος), με προαιρετικό <code class="docutils literal notranslate"><span class="pre">+</span></code> ή <code class="docutils literal notranslate"><span class="pre">-</span></code> μπροστά από τον αριθμό.</p></li>
<li><p>Μετά τον αριθμό ακολουθούν 0 ή περισσότερα κενά (whitespaces, χρησιμοποιήστε το <code class="docutils literal notranslate"><span class="pre">\s</span></code> που ταιριάζει οποιονδήποτε whitespace χαρακτήρα).</p></li>
<li><p>Και τέλος, υποχρεωτικά, τα γράμματα C ή F (κεφαλαία μόνο).</p></li>
<li><p>Ο σκοπός είναι να αναγνωρίσετε θερμοκρασίες, σε κλίμακα Κελσίου ή Φαρενάιτ.</p></li>
<li><p>Ο χρήστης εισάγει μια θερμοκρασία</p>
<ul>
<li><p>Αν έχει την έγκυρη πιο πάνω μορφή, το πρόγραμμά σας θα πρέπει να τυπώνει τη θερμοκρασία στην άλλη κλίμακα από αυτή που έδωσε ο χρήστης.</p></li>
<li><p>Θυμηθείτε να χρησιμοποιήσετε groups για να πάρετε μόνο τα κομμάτια που σας ενδιαφέρουν (θερμοκρασία και κλίμακα).</p></li>
<li><p>Θυμηθείτε πριν κάνετε πράξεις να μετατρέψετε το string του αριθμού σε float.</p></li>
<li><p>Τις πράξεις μετατροπής μπορείτε να τις βρείτε σε πολλά site online.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>Γράψτε κανονική έκφραση που να αναγνωρίζει ονόματα μεταβλητών:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Ο πρώτος χαρακτήρας είναι γράμμα (<code class="docutils literal notranslate"><span class="pre">Α-Ζ</span></code> ή <code class="docutils literal notranslate"><span class="pre">a-z</span></code>) ή <code class="docutils literal notranslate"><span class="pre">_</span></code></p></li>
<li><p>Ακολουθούν 0 ή περισσότεροι χαρακτήρες <code class="docutils literal notranslate"><span class="pre">A-Z</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">_</span></code></p></li>
<li><p><strong>Προσοχή:</strong> θέλουμε ταίριασμα <strong>ολόκληρων λέξεων</strong> μόνο!</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>Γράψτε κανονική έκφραση για να αναγνωρίζετε κείμενο μέσα σε <code class="docutils literal notranslate"><span class="pre">&quot;</span> <span class="pre">&quot;</span></code>.</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Υπόδειξη: χρησιμοποιήστε κλάση χαρακτήρων <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">]</span></code> και τη μέθοδο <code class="docutils literal notranslate"><span class="pre">finditer()</span></code>.</p></li>
</ul>
</div></blockquote>
<ol class="arabic" start="6">
<li><p>Ετοιμάστε πρόγραμμα Python που ανοίγει το αρχείο του <a class="reference external" href="http://mixstef.github.io/courses/compilers/testpage.txt">κειμένου δοκιμών</a> και διαβάζει όλο το περιεχόμενό του σε μια μεταβλητή τύπου string.</p>
<p>Προσθέστε κανονική έκφραση που θα βρίσκει και θα τυπώνει το περιεχόμενο όλων των <code class="docutils literal notranslate"><span class="pre">&lt;meta&gt;</span></code> tags, δηλαδή οτιδήποτε βρίσκεται μεταξύ των <code class="docutils literal notranslate"><span class="pre">&lt;meta</span> <span class="pre">και</span> <span class="pre">/&gt;</span></code>.</p>
<ul class="simple">
<li><p>Πρέπει να χρησιμοποιήσετε μη-άπληστο τελεστή; Ή μπορείτε να το κάνετε με κλάση χαρακτήρων;</p></li>
<li><p>Χρησιμοποιήστε τη μέθοδο <code class="docutils literal notranslate"><span class="pre">finditer()</span></code> του αντικειμένου της κανονικής έκφρασης για να βρείτε όλα τα ταιριάσματα σε ένα <code class="docutils literal notranslate"><span class="pre">for</span></code>.</p></li>
</ul>
<p>Στη συνέχεια, σχεδιάστε δεύτερη κανονική έκφραση η οποία θα εφαρμόζεται σε κάθε ταίριασμα της πρώτης. Η δεύτερη κανονική έκφραση:</p>
<ul>
<li><p>Θα αναγνωρίζει τα <code class="docutils literal notranslate"><span class="pre">property=&quot;...&quot;</span></code> ή <code class="docutils literal notranslate"><span class="pre">content=&quot;...&quot;</span></code> (ξεχωριστά, όχι στο ίδιο ταίριασμα).</p>
<blockquote>
<div><ul class="simple">
<li><p>Προσέξτε να μην αναγνωρίζετε άλλα όπως π.χ. <code class="docutils literal notranslate"><span class="pre">notaproperty=&quot;...&quot;</span></code>!</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Μέσω groups θα πρέπει να εξάγει χωριστά τα (property ή content) και το αντίστοιχο περιεχόμενο μέσα στα <code class="docutils literal notranslate"><span class="pre">&quot;...&quot;</span></code>.</p></li>
</ul>
</li>
<li><p>Χρησιμοποιήστε διαδοχικά τη μέθοδο <code class="docutils literal notranslate"><span class="pre">sub()</span></code>. Το πρόγραμμά σας:</p>
<blockquote>
<div><ul class="simple">
<li><p>Θα διαβάζει ολόκληρο το αρχείο <a class="reference external" href="http://mixstef.github.io/courses/compilers/sampletext.txt">δοκιμαστικού κειμένου</a> (πηγή: <a class="reference external" href="http://tainiothiki.gr/v2/filmography/view/1/836">Ταινιοθήκη της Ελλάδας</a>) σε μια μεταβλητή.</p></li>
<li><p>Θα χρησιμοποιεί πρώτη κανονική έκφραση για να μετατρέψει <strong>συνεχόμενους whitespace χαρακτήρες</strong> σε ακριβώς έναν κενό χαρακτήρα (space).</p></li>
<li><p>Στη συνέχεια θα απαλείφει με δεύτερη κανονική έκφραση <strong>όλα τα σημεία στίξης</strong>, αφήνοντας μόνο λέξεις στο κείμενο, χωρισμένες από ένα κενό μεταξύ τους.</p></li>
<li><p>Θα τυπώνει το τελικό αποτέλεσμα.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Κατεβάστε το εξής <a class="reference external" href="http://mixstef.github.io/courses/compilers/sample1.txt">δοκιμαστικό κείμενο</a>. Τι παρατηρείτε; Στην άσκηση θα διορθώσετε το πρόβλημα με τους τόνους και τα διαλυτικά με τη βοήθεια της <code class="docutils literal notranslate"><span class="pre">sub()</span></code>.</p>
<ul>
<li><p>Η πληροφορία στο αρχείο αυτό βρίσκεται αυτοτελής σε κάθε γραμμή. Έτσι μπορείτε να το επεξεργαστείτε γραμμή προς γραμμή. Αν έχετε προβλήματα encoding, προσθέστε στην <code class="docutils literal notranslate"><span class="pre">open()</span></code> το όρισμα <code class="docutils literal notranslate"><span class="pre">encoding='utf-8'</span></code>.</p></li>
<li><p>Τι συμβαίνει στο κείμενο: τα τονισμένα φωνήεντα δεν έχουν αποθηκευτεί σωστά.</p>
<ul class="simple">
<li><p>Για τους τόνους, προηγείται ο χαρακτήρας <code class="docutils literal notranslate"><span class="pre">'GREEK</span> <span class="pre">TONOS'</span> <span class="pre">(U+0384)</span></code> (στην κανονική σας έκφραση θα το γράψετε ως <code class="docutils literal notranslate"><span class="pre">\u0384</span></code>) και μετά το αντίστοιχο φωνήεν.</p></li>
<li><p>Για τα διαλυτικά, προηγείται ο χαρακτήρας <code class="docutils literal notranslate"><span class="pre">'DIAERESIS'</span> <span class="pre">(U+00A8)</span></code> (στην κανονική σας έκφραση θα το γράψετε ως <code class="docutils literal notranslate"><span class="pre">\u00A8</span></code>) και μετά το αντίστοιχο φωνήεν.</p></li>
<li><p>Δεν υπάρχουν συνδυασμοί τόνου+διαλυτικών.</p></li>
</ul>
</li>
<li><p>Γράψτε κανονική έκφραση που θα:</p>
<blockquote>
<div><ul class="simple">
<li><p>Αναγνωρίζει έναν από τους χαρακτήρες <code class="docutils literal notranslate"><span class="pre">'GREEK</span> <span class="pre">TONOS'</span> <span class="pre">(U+0384)</span></code> ή ‘<code class="docutils literal notranslate"><span class="pre">DIAERESIS'</span> <span class="pre">(U+00A8)</span></code> και τον κρατά <strong>στο group(1)</strong>.</p></li>
<li><p>Κρατά τον επόμενο χαρακτήρα (οποιονδήποτε) στο <strong>group(2)</strong>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Αντιγράψτε τα δύο λεξικά που ακολουθούν στο πρόγραμμά σας:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># the tonos replacement dict</span>
<span class="n">td</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;α&#39;</span><span class="p">:</span><span class="s1">&#39;ά&#39;</span><span class="p">,</span><span class="s1">&#39;ε&#39;</span><span class="p">:</span><span class="s1">&#39;έ&#39;</span><span class="p">,</span><span class="s1">&#39;η&#39;</span><span class="p">:</span><span class="s1">&#39;ή&#39;</span><span class="p">,</span><span class="s1">&#39;ι&#39;</span><span class="p">:</span><span class="s1">&#39;ί&#39;</span><span class="p">,</span><span class="s1">&#39;ο&#39;</span><span class="p">:</span><span class="s1">&#39;ό&#39;</span><span class="p">,</span><span class="s1">&#39;υ&#39;</span><span class="p">:</span><span class="s1">&#39;ύ&#39;</span><span class="p">,</span><span class="s1">&#39;ω&#39;</span><span class="p">:</span><span class="s1">&#39;ώ&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Α&#39;</span><span class="p">:</span><span class="s1">&#39;Ά&#39;</span><span class="p">,</span><span class="s1">&#39;Ε&#39;</span><span class="p">:</span><span class="s1">&#39;Έ&#39;</span><span class="p">,</span><span class="s1">&#39;Η&#39;</span><span class="p">:</span><span class="s1">&#39;Ή&#39;</span><span class="p">,</span><span class="s1">&#39;Ι&#39;</span><span class="p">:</span><span class="s1">&#39;Ί&#39;</span><span class="p">,</span><span class="s1">&#39;Ο&#39;</span><span class="p">:</span><span class="s1">&#39;Ό&#39;</span><span class="p">,</span><span class="s1">&#39;Υ&#39;</span><span class="p">:</span><span class="s1">&#39;Ύ&#39;</span><span class="p">,</span><span class="s1">&#39;Ω&#39;</span><span class="p">:</span><span class="s1">&#39;Ώ&#39;</span> <span class="p">}</span>

<span class="c1"># the dialytika replacement dict</span>
<span class="n">dd</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;ι&#39;</span><span class="p">:</span><span class="s1">&#39;ϊ&#39;</span><span class="p">,</span><span class="s1">&#39;υ&#39;</span><span class="p">:</span><span class="s1">&#39;ϋ&#39;</span><span class="p">,</span><span class="s1">&#39;Ι&#39;</span><span class="p">:</span><span class="s1">&#39;Ϊ&#39;</span><span class="p">,</span><span class="s1">&#39;Υ&#39;</span><span class="p">:</span><span class="s1">&#39;Ϋ&#39;</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Στη συνέχεια, χρησιμοποιήστε συνάρτηση «callback» στη <code class="docutils literal notranslate"><span class="pre">sub()</span></code> της κανονικής έκφρασης που σχεδιάσατε προηγουμένως, έτσι ώστε να επιστρέφετε τη σωστή αντικατάσταση με βάση τα δύο προηγούμενα λεξικά.</p>
<ul class="simple">
<li><p><em>Υποδειξη:</em> επιστρέψτε ό,τι τιμή σας δίνει το λεξικό για το κλειδί m.group(2).</p></li>
<li><p><em>Προσοχή:</em> θα πρέπει να ελέγξετε αν το m.group(2) υπάρχει στο λεξικό. Αν όχι, επιστρέψτε όλο το m.group(0), αφήνοντας ουσιαστικά το σημείο αναλλοίωτο.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Περιεχόμενα</a></h3>
  <ul>
<li><a class="reference internal" href="#">Κανονικές εκφράσεις</a><ul>
<li><a class="reference internal" href="#python">Κανονικές εκφράσεις και Python</a><ul>
<li><a class="reference internal" href="#id2">Χρήση κανονικών εκφράσεων στην Python</a></li>
<li><a class="reference internal" href="#id3">Βασικά σύμβολα κανονικών εκφράσεων</a></li>
<li><a class="reference internal" href="#id4">Παραδείγματα</a><ul>
<li><a class="reference internal" href="#id5">Στην αρχή ή στο τέλος</a></li>
<li><a class="reference internal" href="#id6">Κλάσεις χαρακτήρων</a></li>
<li><a class="reference internal" href="#id7">Εναλλαγή</a></li>
<li><a class="reference internal" href="#id8">Ένας οποιοσδήποτε χαρακτήρας</a></li>
<li><a class="reference internal" href="#id9">Προαιρετικό</a></li>
<li><a class="reference internal" href="#id10">Τελεστές επανάληψης</a></li>
<li><a class="reference internal" href="#id11">Ολόκληρες λέξεις</a></li>
<li><a class="reference internal" href="#groups">Μέρη ταιριασμάτων (groups)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">Η απληστία των τελεστών * και +</a></li>
<li><a class="reference internal" href="#finditer">Η μέθοδος finditer()</a></li>
<li><a class="reference internal" href="#sub">Η μέθοδος sub()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">Ασκήσεις</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
    </div>

    

    
  </body>
</html>