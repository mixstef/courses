.. image:: ../by-sa.png
   :width: 80px
   :alt: Creative Commons Attribution-ShareAlike 4.0 International License

################################################
Παράρτημα Α: Πληροφορίες για την Python3
################################################

Στο παράρτημα αυτό θα βρείτε τα βασικά στοιχεία για να δουλέψετε με την Python στο εργαστήριο των Μεταγλωττιστών. Το παράρτημα ενημερώνεται συνεχώς για τις ανάγκες του μαθήματος, οπότε μπορείτε να το συμβουλεύεστε τακτικά.

.. _install-ref:

*************************
Εγκατάσταση της Python3
*************************

Linux (ή MacOS)
================

Εάν το λειτουργικό σας σύστημα είναι Linux (ή MacOS) έχετε κατά πάσα πιθανότητα τη γλώσσα διαθέσιμη ήδη. Βεβαιωθείτε ότι τρέχετε την 3η έκδοση της γλώσσας -συχνά πρέπει να δώσετε την εντολή ``python3`` (η απλή εντολή ``python`` συνήθως εκτελεί την προηγούμενη έκδοση 2). Δεν απαιτείται πολύ πρόσφατη έκδοση της γλώσσας, οτιδήποτε μεγαλύτερο από την 3.3 είναι αρκετό.

Για παράδειγμα, μπορείτε να μπείτε στο interactive shell της python3 ως εξής (βγείτε με ``exit()`` ή ``Ctrl-D`` όταν τελειώσετε): 

::

	$ python3
	Python 3.5.2 (default, Oct  8 2019, 13:06:37) 
	[GCC 5.4.0 20160609] on linux
	Type "help", "copyright", "credits" or "license" for more information.
	>>>

Για να εκτελέσετε κώδικα που βρίσκεται σε ένα αρχείο (έστω ότι είναι το ``myprogram.py`` στον τρέχοντα φάκελο), δώστε:

::

	$ python3 myprogram.py

Windows
========

Εάν δεν έχετε ήδη εγκαταστήσει την Python3 στο σύστημά σας, πηγαίνετε `στη σελίδα της Python για download <https://www.python.org/downloads/>`_. Βεβαιωθείτε ότι διαλέγετε την πιο πρόσφατη έκδοση 3, κατεβάστε και εκτελέστε τον installer. Θυμηθείτε να ενεργοποιήσετε κατά την εγκατάσταση τις δύο προτεινόμενες επιλογές:

* Την προσθήκη της Python στο ``PATH``
* Την επίτρεψη μεγάλων paths

Μπορείτε τώρα να εκτελέσετε το ``Command Prompt`` για την εμφάνιση της κονσόλας. Ξεκινήστε ένα interactive shell (βγείτε με ``exit()`` ή ``Ctrl-Ζ`` και μετά ``ENTER`` όταν τελειώσετε):

::

	C:\Users\Testuser>python
	Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
	Type "help", "copyright", "credits" or "license" for more information.
	>>>

Για να εκτελέσετε κώδικα που βρίσκεται σε ένα αρχείο (έστω ότι είναι το ``myprogram.py`` στον τρέχοντα φάκελο), δώστε:

::

	C:\Users\Testuser>python myprogram.py


Με την εγκατάσταση της Python έχετε επίσης στη διάθεσή σας το περιβάλλον IDLE για την εκτέλεση προγραμμάτων. Ξεκινήστε το από το μενού όπως κάθε άλλη εφαρμογή.

Εναλλακτικά μπορείτε να ξεκινήσετε το IDLE από την κονσόλα:

::

	C:\Users\Testuser>python -m idlelib


***************************************
Βασικά παραδείγματα χρήσης της Python3
***************************************
Στη συνέχεια παρουσιάζονται ορισμένα ενδιαφέροντα στοιχεία και παραδείγματα χρήσης της Python3. Αυτό που ακολουθεί δεν είναι tutorial, αν θέλετε κάτι τέτοιο μπορείτε να βρείτε εξαιρετικά κείμενα on-line.


Strings
=========

Η Python προσφέρει τους κλασσικούς τύπους δεδομένων (int, string κλπ). Τα αντικείμενα των τύπων αυτών είναι **immutable**, δηλαδή **δεν αλλάζουν τιμή** (μπορούν όμως να δημιουργηθούν νέα αντικείμενα ανά πάσα στιγμή).

Τα **strings** αποτελούν έναν πολύ εύχρηστο τύπο δεδομένων και μερικά χαρακτηριστικά τους δίνονται στη συνέχεια:

Οι σταθερές string εισάγονται με μονά ή διπλά εισαγωγικά

.. code-block:: python
   
    s = "abcd"
    s2 = 'abcd'	# ισοδύναμο με προηγούμενο
   
Τα strings ανήκουν στην κατηγορία τύπων sequence (διατεταγμένης ακολουθίας), άρα μπορούμε να πάρουμε επιμέρους τμήματα

..	code-block:: python

	>>> s = "abcdefg"
	>>> s[0]
	'a'
	>>> s[3]
	'd'
	>>> s[-1]
	'g'
	>>> s[1:4]
	'bcd'
	>>> s[:-1]
	'abcdef'
	>>> s[2:]
	'cdefg'

Για να καταλάβετε καλύτερα το πώς λαμβάνονται τα τμήματα μιας sequence (slicing), μπορείτε να σκεφτείτε ότι ο δείκτης i βρίσκεται ανάμεσα στα (i-1) και i στοιχεία (κι όχι *πάνω* στο στοιχείο i):

::

   [a|b|c|d|e|f|g]
   ^ ^ ^ ^ ^ ^ ^ ^
   0 1 2 3 4 5 6 7
   
   το s[1:4] είναι ίσο με "bcd"
   

Θυμηθείτε όμως ότι **δεν μπορούμε να αλλάξουμε περιεχόμενα σε ένα string** (είναι immutable):

..	code-block:: python

	>>> s = "abcdefg"
	>>> s[3] = 'x'
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	TypeError: 'str' object does not support item assignment


Μπορούμε όμως πάντοτε να δημιουργήσουμε ένα νέο string. Για παράδειγμα, για να επιτύχουμε το προηγούμενο:

..	code-block:: python

	>>> s = "abcdefg"
	>>> s = s[:3]+'x'+s[4:]
	>>> s
	'abcxefg'

Τα αντικείμενα τύπου string διαθέτουν μια μεγάλη σειρά από `χρήσιμες μεθόδους <https://docs.python.org/3/library/stdtypes.html#string-methods>`_.

Σύνθετα Αντικείμενα
=====================

Το δυνατό σημείο της Python είναι τα σύνθετα αντικείμενα που παρέχει, τα οποία χρησιμοποιούμε για όλες τις δομές που θέλουμε να υλοποιήσουμε. Τα δύο βασικότερα είναι οι **λίστες (lists)** και τα **λεξικά (dictionaries)**.  Και οι δύο αυτοί τύποι αντικειμένων είναι **mutable**, τα αντικείμενά τους δηλαδή μπορούν να αλλάξουν περιεχόμενα.

Λίστες (Lists)
-----------------

Οι λίστες ανήκουν στην κατηγορία sequence (όπως και τα strings) και υλοποιούν μια διατεταγμένη συλλογή αντικειμένων. Τα αντικείμενα που περιέχονται στη λίστα μπορούν να είναι οποιουδήποτε τύπου (ακόμα και άλλες λίστες). Εφόσον μια λίστα είναι sequence, μπορούμε να πάρουμε μέρος της, όπως σε ένα string:

..	code-block:: python

	>>> li = [1,2,'abcd','ef']
	>>> li[1]
	2
	>>> li[-1]
	'ef'
	>>> li[:-1]
	[1, 2, 'abcd']

Μπορούμε ακόμα να προσπελάσουμε ένα προς ένα τα στοιχεία της λίστας με την επαναληπτική δομή ``for <item> in <sequence>``:

..	code-block:: python

	>>> for item in li:
	...     print(item)
	... 
	1
	2
	abcd
	ef

Σε αντίθεση με τα strings, **μπορούμε να αλλάξουμε τιμή** σε ένα (υπάρχον) στοιχείο μιας λίστας:

..	code-block:: python

	>>> li = [1,2,'abcd','ef']
	>>> li[0] = 33
	>>> li
	[33, 2, 'abcd', 'ef']

.. topic:: Προσοχή για όσους προέρχονται από τον κόσμο της C!

   Οι αναθέσεις στην Python γίνονται μέσω αναφορών (references) κι όχι με αντιγραφή. Όταν έχουμε mutable αντικείμενα όπως η λίστα, αν δεν προσέξουμε μπορεί να έχουμε απρόβλεπτα αποτελέσματα:
   
   ..	code-block:: python

	 >>> li = [1,2,'abcd','ef']
	 >>> lm = li
	 >>> lm[0] = 33
	 >>> lm
	 [33, 2, 'abcd', 'ef']
	 >>> li
	 [33, 2, 'abcd', 'ef']


Μπορούμε να προσθέσουμε δυναμικά νέα στοιχεία σε μια λίστα:

..	code-block:: python

	>>> li = [1,2,3,'ab','cd']
	>>> li += [11,22]
	>>> li
	[1, 2, 3, 'ab', 'cd', 11, 22]
	>>> li.append(33)
	>>> li
	[1, 2, 3, 'ab', 'cd', 11, 22, 33]

.. topic:: Η συνάρτηση append παίρνει ένα και μοναδικό όρισμα

   Προσέξτε το όρισμα στη μέθοδο append στο προηγούμενο παράδειγμα. **Δεν είναι λίστα**. Αν ήταν, το αποτέλεσμα θα ήταν διαφορετικό!
   
   ..	code-block:: python

	>>> l = [1,2,3]
	>>> l.append([5,6])
	>>> l
	[1, 2, 3, [5, 6]]

   Αν θέλαμε να προσθέσουμε το 5 και το 6 στη λίστα, θα έπρεπε:

   ..	code-block:: python

	>>> l = [1,2,3]
	>>> l += [5,6]
	>>> l
	[1, 2, 3, 5, 6]
     
   Ή εναλλακτικά (η μέθοδος extend() ισοδυναμεί με το + σε λίστες):

   ..	code-block:: python
   
	>>> l = [1,2,3]
	>>> l.extend([5,6])
	>>> l
	[1, 2, 3, 5, 6]


Οι λίστες είναι δομές **ειδικά βελτιστοποιημένες για ταξινόμηση** (sorting). Εάν θέλουμε να ταξινομήσουμε **πολύ γρήγορα** μια σειρά στοιχείων, **η χρήση λίστας είναι MUST!!!**

   ..	code-block:: python
   
	>>> l = [6,8,-1,11]
	>>> l.sort()
	>>> l
	[-1, 6, 8, 11]   

.. _apx-dicts-ref:

Λεξικά (Dictionaries)
------------------------

Τα λεξικά (dictionaries) είναι τύπου mapping: ζεύγη αντιστοιχιών (κλειδιού-τιμής).

* Κάθε κλειδί πρέπει να είναι μοναδικό, αλλά όχι απαραίτητα του ίδιου τύπου με τα άλλα.
* Δεν μπορείτε να χρησιμοποιήσετε λίστες ή λεξικά ως κλειδιά.
* Η τιμή που αντιστοιχεί σε ένα κλειδί μπορεί να είναι οποιουδήποτε τύπου.

Οι πιο κοινές λειτουργίες σε λεξικά δίνονται στη συνέχεια.

Δημιουργήστε ένα κενό ή ένα αρχικοποιημένο με μερικά στοιχεία λεξικό:

..	code-block:: python

	>>> d = {}
	>>> da = { 'mike': 32, 'nick': 43 }

Προσθέστε ένα νέο ζεύγος κλειδιού-τιμής (αν υπάρχει το κλειδί, παίρνει τη νέα τιμή):

..	code-block:: python

	>>> da['stef'] = 67
	>>> da['mike'] = 'oops'
	>>> da
	{'mike': 'oops', 'stef': 67, 'nick': 43}


Ελέγξτε αν ένα κλειδί υπάρχει στο λεξικό:

..	code-block:: python

	>>> if 'stef' in da:
	...     print('found')
	... 
	found


Η απόπειρα προσπέλασης ενός κλειδιού που δεν υπάρχει, **προκαλεί σφάλμα εκτέλεσης**! Πρέπει πάντα να εκτελείτε τον έλεγχο ύπαρξης του κλειδιού πριν την προσπέλαση:
   
..	code-block:: python

	>>> da = { 'mike': 32, 'nick': 43 }
	>>> da['stef']
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	KeyError: 'stef'
  

Προσπελάστε σε loop ένα-ένα τα ζεύγη κλειδιού-τιμής (η σειρά που επιστρέφονται τα στοιχεία εξαρτάται από την υλοποίηση της Python και δεν πρέπει να θεωρείται ντετερμινιστική):

..	code-block:: python

	>>> for k,v in da.items():
	...     print(k,v)
	... 
	mike 32
	stef 67

Τα λεξικά είναι δομές **ειδικά βελτιστοποιημένες για αναζήτηση** (searching). Εάν θέλουμε να αναζητήσουμε **πολύ γρήγορα** ένα στοιχείο μέσα σε ένα μεγάλο σύνολο, **η χρήση λεξικού είναι MUST!!!**


******************************************
Διαβάζοντας ένα ολόκληρο αρχείο κειμένου
******************************************

Στο εργαστήριο επεξεργαζόμαστε το περιεχόμενο αρχείων απλού κειμένου. Στα παραδείγματα που ακολουθούν φαίνεται ο τρόπος για να διαβάσουμε **ολόκληρο το περιεχόμενο** ενός αρχείου κειμένου και να το τοποθετήσουμε σε μια μεταβλητή τύπου string.

.. topic:: Πόσο μεγάλα αρχεία μπορούμε να διαβάσουμε;
     
   Με τα σημερινά δεδομένα μπορείτε να διαβάσετε και να φορτώσετε στη μνήμη του υπολογιστή σας πολύ μεγάλα αρχεία κειμένου. Αν πρόκειται όμως να επεξεργαστείτε αρχεία με π.χ. πάνω από 1 δις γραμμές κειμένου (ναι, υπάρχουν και τέτοια!), είναι καλύτερο να τα διαβάσετε τμηματικά, γραμμή προς γραμμή.
   
Στην αρχή φαίνεται ο τρόπος για να διαβάσουμε ένα ολόκληρο αρχείο από το interactive shell της Python στη μεταβλητή ``text``:

..	code-block:: python

	>>> text = open('testpage.txt','r').read()

Στη συνέχεια, η ίδια λειτουργία σε ένα πρόγραμμα Python:

..	code-block:: python

	with open('testpage.txt','r') as fp:

	  text = fp.read()

Η δομή ``with ... :`` της Python είναι ένας ``context manager``. Θα φροντίσει να κλείσει το αρχείο στο τέλος της, ακόμα και αν ο κώδικας μέσα σε αυτήν προκαλέσει σφάλματα εκτέλεσης.

.. topic:: Προβλήματα με την κωδικοποίηση των χαρακτήρων;
     
   Εάν το πρόγραμμά σας παράγει σφάλματα εκτέλεσης σχετικά με την κωδικοποίηση των χαρακτήρων του αρχείου, δοκιμάστε να προσθέσετε την παράμετρο ``encoding='utf-8'`` στη συνάρτηση ``open()``:

   ..	code-block:: python

	>>> text = open('testpage.txt','r',encoding='utf-8').read()
	
   και αντίστοιχα:
   
   ..	code-block:: python

	with open('testpage.txt','r',encoding='utf-8') as fp:

	  text = fp.read()
   
   
   
